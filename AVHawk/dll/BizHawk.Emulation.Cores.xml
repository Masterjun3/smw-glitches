<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BizHawk.Emulation.Cores</name>
    </assembly>
    <members>
        <member name="M:BizHawk.Emulation.Cores.Arcades.MAME.MAME.FrameAdvance(BizHawk.Emulation.Common.IController,System.Boolean,System.Boolean)">
            <summary>
            MAME fires the periodic callback on every video and debugger update,
            which happens every VBlank and also repeatedly at certain time
            intervals while paused. In our implementation, MAME's emulation
            runs in a separate co-thread, which we swap over with mame_coswitch
            On a periodic callback, control will be switched back to the host
            co-thread. If MAME is internally unpaused, then the next periodic
            callback will occur once a frame is done, making mame_coswitch
            act like a frame advance.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Arcades.MAME.MAME.VsyncAttoseconds">
            <summary>
            Attoseconds for the emulated system's vsync rate.
            Use this to calculate a precise movie time
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Arcades.MAME.MAMEMachineDB._acquire">
            <summary>
            blocks until the DB is done loading
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC">
            <summary>
            CPCHawk: Core Class
            * Controllers *
            </summary>
            <summary>
            CPCHawk: Core Class
            * Main Initialization *
            </summary>
            <summary>
            CPCHawk: Core Class
            * IDebugggable *
            </summary>
            <summary>
            CPCHawk: Core Class
            * IEmulator *
            </summary>
            <summary>
            CPCHawk: Core Class
            * Memory Domains *
            </summary>
            <summary>
            CPCHawk: Core Class
            * IInputPollable *
            </summary>
            <summary>
            CPCHawk: Core Class
            * ISettable *
            </summary>
            <summary>
            CPCHawk: Core Class
            * IStatable *
            </summary>
            <summary>
            CPCHawk: Core Class
            * Handles all messaging (OSD) operations *
            </summary>
            <summary>
            CPCHawk: Core Class
            * Misc Utilities *
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.AmstradCPCControllerDefinition">
            <summary>
            The one CPCHawk ControllerDefinition
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSDVerbosity">
            <summary>
            Verbosity of the CPCHawk generated OSD messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSDVerbosity.Full">
            <summary>
            Show all OSD messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSDVerbosity.Medium">
            <summary>
            Only show machine/device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSDVerbosity.None">
            <summary>
            No core-driven OSD messages
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.CPCMachineMetaData">
            <summary>
            Provides information on each emulated machine
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.BorderType">
            <summary>
            The size of the Spectrum border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.BorderType.Visible">
            <summary>
            Roughly what you might see on an Amstrad monitor
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.BorderType.Uncropped">
            <summary>
            The full display area
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.SendMessage(System.String,BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory)">
            <summary>
            Writes a message to the OSD
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_FireInputMessage(System.String)">
            <summary>
            Called when certain input presses are detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_DiskInit">
            <summary>
            Disk message that is fired on core init
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_DiskInserted">
            <summary>
            Disk message that is fired when a new disk is inserted into the drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_ShowDiskStatus">
            <summary>
            Tape message that prints the current status of the tape device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeInit">
            <summary>
            Tape message that is fired on core init
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeMotorActive">
            <summary>
            Tape message that is fired when tape is playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeMotorInactive">
            <summary>
            Tape message that is fired when tape is playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapePlaying">
            <summary>
            Tape message that is fired when tape is playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeStopped">
            <summary>
            Tape message that is fired when tape is stopped
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeRTZ">
            <summary>
            Tape message that is fired when tape is rewound
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeInserted">
            <summary>
            Tape message that is fired when a new tape is inserted into the datacorder
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeStoppedAuto">
            <summary>
            Tape message that is fired when a tape is stopped automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapePlayingAuto">
            <summary>
            Tape message that is fired when a tape is started automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapePlayingBlockInfo(System.String)">
            <summary>
            Tape message that is fired when a new block starts playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapePlayingSkipBlockInfo(System.String)">
            <summary>
            Tape message that is fired when a tape block is skipped (because it is empty)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeEndDetected(System.String)">
            <summary>
            Tape message that is fired when a tape is started automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapeNextBlock(System.String)">
            <summary>
            Tape message that is fired when user has manually skipped to the next block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_TapePrevBlock(System.String)">
            <summary>
            Tape message that is fired when user has manually skipped to the next block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.OSD_ShowTapeStatus">
            <summary>
            Tape message that prints the current status of the tape device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.CheckMessageSettings(BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory)">
            <summary>
            Checks whether message category is allowed to be sent
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory">
            <summary>
            Defines the different message categories
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory.Misc">
            <summary>
            No defined category as such
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory.Input">
            <summary>
            User generated input messages (at the moment only tape/disk controls)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory.Tape">
            <summary>
            Tape device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory.Disk">
            <summary>
            Disk device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.MessageCategory.Emulator">
            <summary>
            Emulator generated messages
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.GetIntFromBitArray(System.Collections.BitArray)">
            <summary>
            Helper method that returns a single INT32 from a BitArray
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.PokeMemory(System.UInt16,System.Byte)">
            <summary>
            POKEs a memory bus address
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.JoystickType">
            <summary>
            The possible joystick types
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IBeeperDevice">
            <summary>
            Represents a beeper/buzzer device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IBeeperDevice.Init(System.Int32,System.Int32)">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IBeeperDevice.ProcessPulseValue(System.Boolean)">
            <summary>
            Processes an incoming pulse value and adds it to the blipbuffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IBeeperDevice.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IFDDHost">
            <summary>
            Defines an object that can load a floppy disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IFDDHost.Disk">
            <summary>
            The currently inserted disk image
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IFDDHost.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IFDDHost.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IFDDHost.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick">
            <summary>
            Represents a spectrum joystick
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick.JoyType">
            <summary>
            The type of joystick
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick.ButtonCollection">
            <summary>
            Array of all the possibly button press names
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick.PlayerNumber">
            <summary>
            The player number that this controller is currently assigned to
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IJoystick.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard">
            <summary>
            Represents a spectrum keyboard
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard._machine">
            <summary>
            The calling spectrumbase class
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.KeyboardMatrix">
            <summary>
            The keyboard matrix for a particular CPC model
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.NonMatrixKeys">
            <summary>
            Other keyboard keys that are not in the matrix
            (usually keys derived from key combos)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.KeyStatus">
            <summary>
            Represents the spectrum key state
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.CurrentLine">
            <summary>
            The currently selected line
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.ReadCurrentLine">
            <summary>
            Reads the current line status
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.SetKeyStatus(System.String,System.Boolean)">
            <summary>
            Sets the CPC key status
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IKeyboard.GetKeyStatus(System.String)">
            <summary>
            Gets the status of a CPC key
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPortIODevice">
            <summary>
            Represents a device that utilizes port IN &amp; OUT
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPortIODevice.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPortIODevice.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG">
            <summary>
            Represents a PSG device (in this case an AY-3-891x)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.Init(System.Int32,System.Int32)">
            <summary>
            Initialization routine
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.SelectedRegister">
            <summary>
            Activates a register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.PortWrite(System.Int32)">
            <summary>
            Writes to the PSG
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.PortRead">
            <summary>
            Reads from the PSG
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.Reset">
            <summary>
            Resets the PSG
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.Volume">
            <summary>
            The volume of the AY chip
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.StartFrame">
            <summary>
            Called at the start of a frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.EndFrame">
            <summary>
            called at the end of a frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.UpdateSound(System.Int32)">
            <summary>
            Updates the sound based on number of frame cycles
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.IPSG.SyncState(BizHawk.Common.Serializer)">
            <summary>
            IStatable serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912">
            <summary>
            Based heavily on the YM-2149F / AY-3-8910 emulator used in Unreal Speccy
            (Originally created under Public Domain license by SMT jan.2006)    /// 
            https://github.com/mkoloberdin/unrealspeccy/blob/master/sndrender/sndchip.cpp
            https://github.com/mkoloberdin/unrealspeccy/blob/master/sndrender/sndchip.h
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._machine">
            <summary>
            The emulated machine (passed in via constructor)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.#ctor(BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase)">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.Init(System.Int32,System.Int32)">
            <summary>
            Initialises the AY chip
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.AYPanConfig">
            <summary>
            AY mixer panning configuration
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.PanningConfiguration">
            <summary>
            The AY panning configuration
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.Volume">
            <summary>
            The AY chip output volume
            (0 - 100)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.SelectedRegister">
            <summary>
            The currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.Reset">
            <summary>
            Resets the PSG
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.ActiveFunction">
            <summary>
            0:  Inactive
            1:  Read Register
            2:  Write Register
            3:  Select Register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.PortRead">
            <summary>
            Reads the value from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.PortWrite(System.Int32)">
            <summary>
            Writes to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.StartFrame">
            <summary>
            Start of frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.EndFrame">
            <summary>
            End of frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.UpdateSound(System.Int32)">
            <summary>
            Updates the audiobuffer based on the current frame t-state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.AY_A_FINE">
            <summary>
            Register indicies
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._registers">
            <summary>
            The register array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._activeRegister">
            <summary>
            The currently selected register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._chipFrequency">
            <summary>
            The frequency of the AY chip
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._resolution">
            <summary>
            The rendering resolution of the chip
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._bitA">
            <summary>
            Channel generator state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._eState">
            <summary>
            Envelope state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._eDirection">
            <summary>
            Envelope direction
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._noiseSeed">
            <summary>
            Noise seed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._bit0">
            <summary>
            Mixer state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._bitN">
            <summary>
            Noise generator state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._eMaskA">
            <summary>
            Envelope masks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._vA">
            <summary>
            Amplitudes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._countA">
            <summary>
            Channel gen counters
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._countE">
            <summary>
            Envelope gen counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._countN">
            <summary>
            Noise gen counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._dividerA">
            <summary>
            Channel gen dividers
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._dividerE">
            <summary>
             Envelope gen divider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._dividerN">
            <summary>
            Noise gen divider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.PanTabs">
            <summary>
            Panning table list
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._currentPanTab">
            <summary>
            The currently selected panning configuration
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._volume">
            <summary>
            The current volume
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912._volumeTables">
            <summary>
            Volume tables state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.AYVolumes">
            <summary>
            Volume table to be used
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.UpdateVolume">
            <summary>
            Forces an update of the volume tables
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.InitTiming(System.Int32,System.Int32)">
            <summary>
            Initializes timing information for the frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.BufferUpdate(System.Int32)">
            <summary>
            Updates the audiobuffer based on the current frame t-state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.AY38912.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper">
            <summary>
            Logical Beeper class
            Used to emulate the sound generated by tape loading
            This implementation uses BlipBuffer and should *always* output at 44100 with 882 samples per frame
            (so that it can be mixed easily further down the line)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper._sampleRate">
            <summary>
            Sample Rate 
            This usually has to be 44100 for ISoundProvider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper._volume">
            <summary>
            Buzzer volume
            Accepts an int 0-100 value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.lastVolume">
            <summary>
            The last used volume (used to modify blipbuffer delta values)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper._tStatesPerFrame">
            <summary>
            The number of cpu cycles per frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper._machine">
            <summary>
            The parent emulated machine
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.LastPulse">
            <summary>
            The last pulse
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.LastPulseTState">
            <summary>
            The last T-State (cpu cycle) that the last pulse was received
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.blip">
            <summary>
            Device blipbuffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.VolumeConverterIn(System.Int32)">
            <summary>
            Takes an int 0-100 and returns the relevant short volume to output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.VolumeConverterOut(System.Int32)">
            <summary>
            Takes an short volume and returns the relevant int value 0-100
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.Init(System.Int32,System.Int32)">
            <summary>
            Initialises the beeper
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.Beeper.ProcessPulseValue(System.Boolean)">
            <summary>
            Processes an incoming pulse value and adds it to the blipbuffer
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC">
             <summary>
             CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
             http://www.cpcwiki.eu/index.php/CRTC
             http://cpctech.cpc-live.com/docs/cpcplus.html
             https://shaker.logonsystem.eu/
             https://shaker.logonsystem.eu/ACCC1.8-EN.pdf
             https://shaker.logonsystem.eu/tests
             This implementation aims to emulate all the various CRTC chips that appear within
             the CPC, CPC+ and GX4000 ranges. The CPC community have assigned them type numbers.
             If different implementations share the same type number it indicates that they are functionally identical
             
             Part No.      Manufacturer    Type No.    Info.
             ------------------------------------------------------------------------------------------------------
             HD6845S       Hitachi         0
             Datasheet:    http://www.cpcwiki.eu/imgs/c/c0/Hd6845.hitachi.pdf
             ------------------------------------------------------------------------------------------------------
             UM6845        UMC             0
             Datasheet:    http://www.cpcwiki.eu/imgs/1/13/Um6845.umc.pdf
             ------------------------------------------------------------------------------------------------------
             UM6845R       UMC             1
             Datasheet:    http://www.cpcwiki.eu/imgs/b/b5/Um6845r.umc.pdf
             ------------------------------------------------------------------------------------------------------
             MC6845        Motorola        2
             Datasheet:    http://www.cpcwiki.eu/imgs/d/da/Mc6845.motorola.pdf &amp; http://bitsavers.trailing-edge.com/components/motorola/_dataSheets/6845.pdf
             ------------------------------------------------------------------------------------------------------
             AMS40489      Amstrad         3           Only exists in the CPC464+, CPC6128+ and GX4000 and is integrated into a single CPC+ ASIC chip (along with the gatearray)
             Datasheet:    {none}
             ------------------------------------------------------------------------------------------------------
             AMS40041      Amstrad         4           'Pre-ASIC' IC. The CRTC is integrated into a aingle ASIC IC with functionality being almost identical to the AMS40489
             (or 40226)                                Used in the 'Cost-Down' range of CPC464 and CPC6128 systems
             Datasheet:    {none}
            
             </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.Create(System.Int32)">
            <summary>
            Instantiation helper
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.RegDefaults">
            <summary>
            CPC register default values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.CLK">
            <summary>
            The ClK isaTTUMOS-compatible input used to synchronize all CRT' functions except for the processor interface. 
            An external dot counter is used to derive this signal which is usually the character rate in an alphanumeric CRT.
            The active transition is high-to-low
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.HSYNC">
            <summary>
            This TTL compatible  output is an active high signal which drives the monitor directly or is fed to Video Processing Logic for composite generation.
            This signal determines the horizontal position of the displayed text. 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VSYNC">
            <summary>
            This TTL compatible output is an active high signal which drives the monitor directly or is fed to Video Processing Logic for composite generation.
            This signal determines the vertical position of the displayed text.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.DISPTMG">
            <summary>
            This TTL compatible output is an active high signal which indicates the CRTC is providing addressing in the active Display Area.
            </summary>      
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.CUDISP">
            <summary>
            This TTL compatible output indicates Cursor Display to external Video Processing Logic.Active high signal. 
            </summary>       
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ma">
            <summary>
            Linear Address Generator
            Character pos address (0 index).
            Feeds the MA lines
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ma_row_start">
            <summary>
            Memory address reset latch
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ma_store">
            <summary>
            Internal latch for storing intermediate MA values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC._RA">
            <summary>
            Generated by the Vertical Control Raster Counter
            Feeds the RA lines
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.MA_Address">
            <summary>
            This 16-bit property emulates how the Amstrad CPC Gate Array is wired up to the CRTC
            Built from LA, RA and CLK
            
            Memory Address Signal    Signal source    Signal name
            A15                      6845             MA13
            A14                      6845             MA12
            A13                      6845             RA2
            A12                      6845             RA1
            A11                      6845             RA0
            A10                      6845             MA9
            A9                       6845             MA8
            A8                       6845             MA7
            A7                       6845             MA6
            A6                       6845             MA5
            A5                       6845             MA4
            A4                       6845             MA3
            A3                       6845             MA2
            A2                       6845             MA1
            A1                       6845             MA0
            A0                       Gate-Array       CLK
            </summary>		
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.CallBack">
            <summary>
            Public Delegate
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.HSYNC_On_Callbacks">
            <summary>
            Fired on CRTC HSYNC signal rising edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.HSYNC_Off_Callbacks">
            <summary>
            Fired on CRTC HSYNC signal falling edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VSYNC_On_Callbacks">
            <summary>
            Fired on CRTC VSYNC signal rising edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VSYNC_Off_Callbacks">
            <summary>
            Fired on CRTC VSYNC signal falling edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC._inReset">
            <summary>
            Reset Counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.AddressRegister">
            <summary>
            This is a 5 bit register which is used as a pointer to direct data transfers to and from the system MPU
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R0_H_TOTAL">
            <summary>
            This 8 bit write-only register determines the horizontal frequency of HS. 
            It is the total of displayed plus non-displayed character time units minus one.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R1_H_DISPLAYED">
            <summary>
            This 8 bit write-only register determines the number of displayed characters per horizontal line.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R2_H_SYNC_POS">
            <summary>
            This 8 bit write-only register determines the horizontal sync postiion on the horizontal line.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R3_SYNC_WIDTHS">
            <summary>
            This 4 bit  write-only register determines the width of the HS pulse. It may not be apparent why this width needs to be programmed.However, 
            consider that all timing widths must be programmed as multiples of the character clock period which varies.If HS width were fixed as an integral 
            number of character times, it would vary with character rate and be out of tolerance for certain monitors.
            The rate programmable feature allows compensating HS width.
            NOTE: Dependent on chiptype this also may include VSYNC width - check the UpdateWidths() method
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R4_V_TOTAL">
            <summary>
            The vertical frequency of VS is determined by both R4 and R5.The calculated number of character I ine times is usual I y an integer plus a fraction to 
            get exactly a 50 or 60Hz vertical refresh rate. The integer number of character line times minus one is programmed in the 7 bit write-only Vertical Total Register; 
            the fraction is programmed in the 5 bit write-only Vertical Scan Adjust Register as a number of scan line times.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R6_V_DISPLAYED">
            <summary>
            This 7 bit write-only register determines the number of displayed character rows on the CRT screen, and is programmed in character row times.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R7_V_SYNC_POS">
            <summary>
            This 7 bit write-only register determines the vertical sync position with respect to the reference.It is programmed in character row times.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R8_INTERLACE_MODE">
            <summary>
            This 2 bit write-only  register controls the raster scan mode(see Figure 11 ). When bit 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, 
            the non· interlace raster scan mode is selected.Two interlace modes are available.Both are interlaced 2 fields per frame.When bit 0 is set and bit 1 is reset, 
            the interlace sync raster scan mode is selected.Also when bit 0 and bit 1 are set, the interlace sync and video raster scan mode is selected.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R9_MAX_SL_ADDRESS">
            <summary>
            This 5 bit write·only register determines the number of scan lines per character row including spacing.
            The programmed value is a max address and is one less than the number of scan l1nes.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R10_CURSOR_START">
            <summary>
            This 7 bit write-only register controls the cursor format(see Figure 10). Bit 5 is the blink timing control.When bit 5 is low, the blink frequency is 1/16 of the 
            vertical field rate, and when bit 5 is high, the blink frequency is 1/32 of the vertical field rate.Bit 6 is used to enable a blink.
            The cursor start scan line is set by the lower 5 bits. 
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R11_CURSOR_END">
            <summary>
            This 5 bit write-only register sets the cursor end scan line
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R12_START_ADDR_H">
            <summary>
            Start Address Register is a 14 bit write-only register which determines the first address put out as a refresh address after vertical blanking.
            It consists of an 8 bit lower register, and a 6 bit higher register.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R14_CURSOR_H">
            <summary>
            This 14 bit read/write register stores the cursor location.This register consists of an 8 bit lower and 6 bit higher register.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R16_LIGHT_PEN_H">
            <summary>
            This 14 bit read -only register is used to store the contents of the Address Register(H &amp; L) when the LPSTB input pulses high.
            This register consists of an 8 bit lower and 6 bit higher register.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.Register">
            <summary>
            Storage for main MPU registers 
            
            RegIdx    Register Name                 Type
                                                    0             1             2             3                      4
            0         Horizontal Total              Write Only    Write Only    Write Only    (note 2)               (note 3)
            1         Horizontal Displayed          Write Only    Write Only    Write Only    (note 2)               (note 3)
            2         Horizontal Sync Position      Write Only    Write Only    Write Only    (note 2)               (note 3)
            3         H and V Sync Widths           Write Only    Write Only    Write Only    (note 2)               (note 3)
            4         Vertical Total                Write Only    Write Only    Write Only    (note 2)               (note 3)
            5         Vertical Total Adjust         Write Only    Write Only    Write Only    (note 2)               (note 3)
            6         Vertical Displayed            Write Only    Write Only    Write Only    (note 2)               (note 3)
            7         Vertical Sync position        Write Only    Write Only    Write Only    (note 2)               (note 3)
            8         Interlace and Skew            Write Only    Write Only    Write Only    (note 2)               (note 3)
            9         Maximum Raster Address        Write Only    Write Only    Write Only    (note 2)               (note 3)
            10        Cursor Start Raster           Write Only    Write Only    Write Only    (note 2)               (note 3)
            11        Cursor End Raster             Write Only    Write Only    Write Only    (note 2)               (note 3)
            12        Disp. Start Address (High)    Read/Write    Write Only    Write Only    Read/Write (note 2)    (note 3)
            13        Disp. Start Address (Low)     Read/Write    Write Only    Write Only    Read/Write (note 2)    (note 3)
            14        Cursor Address (High)         Read/Write    Read/Write    Read/Write    Read/Write (note 2)    (note 3)
            15        Cursor Address (Low)          Read/Write    Read/Write    Read/Write    Read/Write (note 2)    (note 3)
            16        Light Pen Address (High)      Read Only     Read Only     Read Only     Read Only (note 2)     (note 3)
            
            18-31	  Not Used
            
            1. On type 0 and 1, if a Write Only register is read from, "0" is returned.
            2. See the document "Extra CPC Plus Hardware Information" for more details.
            3. CRTC type 4 is the same as CRTC type 3. The registers also repeat as they do on the type 3.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.StatusRegister">
            <summary>
            Internal Status Register specific to the Type 1 UM6845R
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R0_HorizontalTotal">
            <summary>
            R0: CRTC-type horizontal total independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R1_HorizontalDisplayed">
            <summary>
            R1: CRTC-type horizontal displayed independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R2_HorizontalSyncPosition">
            <summary>
            R2: CRTC-type horizontal sync position independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R4_VerticalTotal">
            <summary>
            R4: CRTC-type vertical total independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R5_VerticalTotalAdjust">
            <summary>
            R5: CRTC-type vertical total adjust independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R6_VerticalDisplayed">
            <summary>
            R6: CRTC-type vertical displayed independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R7_VerticalSyncPosition">
            <summary>
            R7: CRTC-type vertical sync position independent helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type DISPTMG Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R8_Interlace">
            <summary>
            R8: CRTC-type Interlace Mode helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.R9_MaxScanline">
            <summary>
            R9: Max Scanlines
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.HCC">
            <summary>
            C0: Horizontal Character Counter
            8-bit
            </summary>		
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.HSC">
            <summary>
            C3l: Horizontal Sync Width Counter (HSYNC)
            4-bit
            </summary>		
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VCC">
            <summary>
            C4: Vertical Character Row Counter
            7-bit
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VSC">
            <summary>
            C3h: Vertical Sync Width Counter (VSYNC)
            4-bit
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VLC">
            <summary>
            C9: Vertical Line Counter (Scanline Counter)
            5-bit
            If not in IVM mode, this counter is exposed on CRTC pins RA0..RA4
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.VTAC">
            <summary>
            C5: Vertical Total Adjust Counter
            5-bit??
            This counter does not exist on CRTCs 0/3/4. C9 (VLC) is reused instead
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.CFC">
            <summary>
            Field Counter
            6-bit
            Used for cursor flash - counts the number of completed fields
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.Clock">
            <summary>
            CRTC is clocked at 1MHz (16 GA cycles)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.SelectRegister(System.Int32)">
            <summary>
            Selects a specific register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ReadStatus(System.Int32@)">
            <summary>
            Attempts to read from the internal status register (if present)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC.Reset">
            <summary>
            Simulates the RESET pin
            This should take at least one cycle
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0">
            <summary>
            CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
            TYPE 0
            - Hitachi HD6845S	http://www.cpcwiki.eu/imgs/c/c0/Hd6845.hitachi.pdf
            - UMC UM6845		http://www.cpcwiki.eu/imgs/1/13/Um6845.umc.pdf
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type0.ReadStatus(System.Int32@)">
            <summary>
            CRTC 0 has no status register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1">
            <summary>
            CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
            TYPE 1
            - UMC UM6845R		http://www.cpcwiki.eu/imgs/b/b5/Um6845r.umc.pdf
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.Clock">
            <summary>
            CRTC is clocked at 1MHz (16 GA cycles)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type1.ReadStatus(System.Int32@)">
            <summary>
            CRTC 1 has a status register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2">
            <summary>
            CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
            TYPE 2
            - Motorola MC6845
            http://www.cpcwiki.eu/imgs/d/da/Mc6845.motorola.pdf
            http://bitsavers.trailing-edge.com/components/motorola/_dataSheets/6845.pdf
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type2.ReadStatus(System.Int32@)">
            <summary>
            CRTC 2 has no status register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3">
            <summary>
            CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
            TYPE 3
            - Amstrad AMS40489
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type3.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4">
            <summary>
            CATHODE RAY TUBE CONTROLLER (CRTC) IMPLEMENTATION
            TYPE 4
            - Amstrad AMS40041
            - Amstrad AMS40226
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.CrtcType">
            <summary>
            Defined CRTC type number
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.R3_HorizontalSyncWidth">
            <summary>
            R3l: CRTC-type horizontal sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.R3_VerticalSyncWidth">
            <summary>
            R3h: CRTC-type vertical sync width independent helper function 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.R8_Skew_CUDISP">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.R8_Skew_DISPTMG">
            <summary>
            R8: CRTC-type CUDISP Active Display Skew helper function
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.ReadRegister(System.Int32@)">
            <summary>
            Attempts to read from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTC_Type4.WriteRegister(System.Int32)">
            <summary>
            Attempts to write to the currently selected register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice">
            <summary>
            Represents the tape device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.Init(BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase)">
            <summary>
            Initializes the datacorder device
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.tapeMotor">
            <summary>
            Signs whether the tape motor is running
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.counter">
            <summary>
            Internal counter used to trigger tape buzzer output
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._currentDataBlockIndex">
            <summary>
            The index of the current tape data block that is loaded
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._position">
            <summary>
            The current position within the current data block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._tapeIsPlaying">
            <summary>
            Signs whether the tape is currently playing or not
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._lastCycle">
            <summary>
            Stores the last CPU t-state value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._waitEdge">
            <summary>
            Edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.currentState">
            <summary>
            Current tapebit state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice._autoPlay">
            <summary>
            Signs whether the device should autodetect when the Z80 has entered into
            'load' mode and auto-play the tape if neccesary
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.EndFrame">
            <summary>
            Should be fired at the end of every frame
            Primary purpose is to detect tape traps and manage auto play (if/when this is ever implemented)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.Play">
            <summary>
            Starts the tape playing from the beginning of the current block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.Stop">
            <summary>
            Stops the tape
            (should move to the beginning of the next block)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.RTZ">
            <summary>
            Rewinds the tape to it's beginning (return to zero)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.SkipBlock(System.Boolean)">
            <summary>
            Performs a block skip operation on the current tape
            TRUE:   skip forward
            FALSE:  skip backward
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.LoadTape(System.Byte[])">
            <summary>
            Inserts a new tape and sets up the tape device accordingly
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.Reset">
            <summary>
            Resets the tape
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.TapeCycle">
            <summary>
            Is called every cpu cycle but runs every 50 t-states
            This enables the tape devices to play out even if the spectrum itself is not
            requesting tape data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.GetEarBit(System.Int64)">
            <summary>
            Simulates the spectrum 'EAR' input reading data from the tape
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.TAPE_BIT">
            <summary>
            Mask constants
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.ReadPort">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.WritePort(System.Boolean)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.DatacorderDevice.SyncState(BizHawk.Common.Serializer)">
            <summary>
            BizHawk state serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN">
            <summary>
            Used for the sector CHRN structure
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.C">
            <summary>
            Track
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.H">
            <summary>
            Side
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.R">
            <summary>
            Sector ID
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.N">
            <summary>
            Sector Size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN._flag1">
            <summary>
            Status register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN._flag2">
            <summary>
            Status register 2
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.DataBytes">
            <summary>
            Used to store the last transmitted/received data bytes
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.DataID">
            <summary>
            ID for the read/write data command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST1MA">
            <summary>
            Missing Address Mark (Sector_ID or DAM not found)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST1ND">
            <summary>
            No Data (Sector_ID not found, CRC fail in ID_field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST1DE">
            <summary>
            Data Error (CRC-fail in ID- or Data-Field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST1EN">
            <summary>
            End of Track (set past most read/write commands) (see IC)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST2MD">
            <summary>
            Missing Address Mark in Data Field (DAM not found)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST2BC">
            <summary>
            Bad Cylinder (read/programmed track-ID different and read-ID = FF)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST2WC">
            <summary>
            Wrong Cylinder (read/programmed track-ID different) (see b1)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST2DD">
            <summary>
            Data Error in Data Field (CRC-fail in data-field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CHRN.ST2CM">
            <summary>
            Control Mark (read/scan command found sector with deleted DAM)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765">
            <summary>
            The NEC floppy disk controller (and floppy drive) found in the +3
            </summary>
            <summary>
            Definitions
            </summary>
            <summary>
            FDC State and Methods
            </summary>
            <summary>
            Floppy drive related stuff
            </summary>
            <summary>
            IPortIODevice
            </summary>
            <summary>
            Timimng
            </summary>
            <summary>
            Static helper methods
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765._machine">
            <summary>
            The emulated spectrum machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.#ctor">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Init(BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase)">
            <summary>
            Initialization routine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Reset">
            <summary>
            Resets the FDC
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InitCommandList">
            <summary>
            Setup the command structure
            Each command represents one of the internal UPD765 commands
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Phase">
            <summary>
            Defines the current phase of the controller
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Phase.Idle">
            <summary>
            FDC is in an idle state, awaiting the next initial command byte
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Phase.Command">
            <summary>
            FDC is in a state waiting for the next command instruction
            A command consists of a command byte (eventually including the MF, MK, SK bits), and up to eight parameter bytes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Phase.Execution">
            <summary>
            During this phase, the actual data is transferred (if any). Usually that are the data bytes for the read/written sector(s), except for the Format Track Command, 
            in that case four bytes for each sector are transferred
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Phase.Result">
            <summary>
            Returns up to seven result bytes (depending on the command) that are containing status information. The Recalibrate and Seek Track commands do not return result bytes directly, 
            instead the program must wait until the Main Status Register signalizes that the command has been completed, and then it must (!) send a 
            Sense Interrupt State command to 'terminate' the Seek/Recalibrate command.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState">
            <summary>
            The lifecycle of an instruction
            Similar to phase, this describes the current 'sub-phase' we are in when dealing with an instruction
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.ReceivingParameters">
            <summary>
            FDC has received a command byte and is currently reading parameter bytes from the data bus
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.PreExecution">
            <summary>
            All parameter bytes have been received. This phase allows any neccessary setup before instruction execution starts
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.StartExecute">
            <summary>
            The start of instruction execution. This may end up with the FDC moving into result phase, 
            but also may also prepare the way for further processing to occur later in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.ExecutionReadWrite">
            <summary>
            Data is read or written in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.ExecutionWrite">
            <summary>
            Execution phase is well under way. This state primarily deals with data transfer between CPU and FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.ExecutionRead">
            <summary>
            Execution phase is well under way. This state primarily deals with data transfer between FDC and CPU
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.StartResult">
            <summary>
            Execution has finished and results bytes are ready to be read by the CPU
            Initial result setup
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.ProcessResult">
            <summary>
            Result processing
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.SendingResults">
            <summary>
            Results are being sent
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InstructionState.Completed">
            <summary>
            Final cleanup tasks when the instruction has fully completed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState">
            <summary>
            Represents internal interrupt state of the FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState.None">
            <summary>
            There is no interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState.Execution">
            <summary>
            Execution interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState.Result">
            <summary>
            Result interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState.Ready">
            <summary>
            Ready interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptState.Seek">
            <summary>
            Seek interrupt
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState">
            <summary>
            Possible main states that each drive can be in
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.None">
            <summary>
            Drive is not doing anything
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.Seek">
            <summary>
            Seek operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.Recalibrate">
            <summary>
            Recalibrate operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.Scan">
            <summary>
            A scan data operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.ReadID">
            <summary>
            A read ID operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.ReadData">
            <summary>
            A read data operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.ReadDiagnostic">
            <summary>
            A read diagnostic (read track) operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.WriteID">
            <summary>
            A write id (format track) operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveMainState.WriteData">
            <summary>
            A write data operation is in progress
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState">
            <summary>
            State information during a seek/recalibration operation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.Idle">
            <summary>
            Seek hasnt started yet
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.Wait">
            <summary>
            Delayed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.MoveInit">
            <summary>
            Setup for head move
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.HeadMove">
            <summary>
            Seek is currently happening
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.MoveImmediate">
            <summary>
            Head move with no delay
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.PerformCompletion">
            <summary>
            Ready to complete
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekSubState.SeekCompleted">
            <summary>
            Seek operation has completed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SeekIntStatus">
            <summary>
            Seek int code
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandDirection">
            <summary>
            The direction of a specific command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandDirection.OUT">
            <summary>
            Data flows from UPD765A to Z80
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandDirection.IN">
            <summary>
            Data flows from Z80 to UPD765A
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResultType">
            <summary>
            Enum defining the different types of result that can be returned
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResultType.Standard">
            <summary>
            Standard 7 result bytes are returned
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResultType.ST3">
            <summary>
            1 byte returned - ST3
            (used for SenseDriveStatus)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResultType.ST0">
            <summary>
            1 byte returned - ST0
            (used for version &amp; invalid)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResultType.Interrupt">
            <summary>
            2 bytes returned for sense interrupt status command
            ST0
            CurrentCylinder
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status">
            <summary>
            Possible list of encountered drive status errors
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.None">
            <summary>
            No error detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.Undefined">
            <summary>
            An undefined error has been detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.DriveNotReady">
            <summary>
            Drive is not ready
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.Invalid">
            <summary>
            Invalid command received
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.WriteProtected">
            <summary>
            The disk has its write protection tab enabled
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status.SectorNotFound">
            <summary>
            The requested sector has not been found
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SkipDirection">
            <summary>
            Represents the direction that the head is moving over the cylinders
            Increment:  Track number increasing (head moving from outside of disk inwards)
            Decrement:  Track number decreasing (head moving from inside of disk outwards)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_C">
            <summary>
            C - Track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_H">
            <summary>
            H - Side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_R">
            <summary>
            R - Sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_N">
            <summary>
            N - Sector size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_EOT">
            <summary>
            EOT - End of track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_GPL">
            <summary>
            GPL - Gap length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_DTL">
            <summary>
            DTL - Data length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CM_STP">
            <summary>
            STP - Step
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_ST0">
            <summary>
            Status register 0
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_ST1">
            <summary>
            Status register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_ST2">
            <summary>
            Status register 2
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_C">
            <summary>
            C - Track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_H">
            <summary>
            H - Side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_R">
            <summary>
            R - Sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.RS_N">
            <summary>
            N - Sector size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_D0B">
            <summary>
            FDD0 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 0 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_D1B">
            <summary>
            FDD1 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 1 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_D2B">
            <summary>
            FDD2 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 2 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_D3B">
            <summary>
            FDD3 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 3 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_CB">
            <summary>
            FDC Busy (still in command-, execution- or result-phase)
            A Read or Write command is in orocess. (FDC Busy) FDC will not accept any other command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_EXM">
            <summary>
            Execution Mode (still in execution-phase, non_DMA_only)
            This bit is set only during execution ohase (Execution Mode) in non-DMA mode When DB5 goes low, execution phase has ended and result phase has started.It operates only during
             non-DMA mode of operation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_DIO">
            <summary>
            Data Input/Output (0=CPU->FDC, 1=FDC->CPU) (see b7)
            Indicates direction of data transfer between FDC and data regrster If DIO = 1, then transfer is from data register to the
            processor.If DIO = 0, then transfer is from the processor to data register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.MSR_RQM">
            <summary>
            Request For Master (1=ready for next byte) (see b6 for direction)
            ndicates data register IS ready to send or receive data to or from the processor Both bits DIO and RQM should be 
            used to perform the hand-shaking functions of “ready” and “directron” to the processor
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_US0">
            <summary>
            Unit Select (driveno during interrupt)
            This flag IS used to indicate a drive unit number at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_US1">
            <summary>
            Unit Select (driveno during interrupt)
            This flag IS used to indicate a drive unit number at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_HD">
            <summary>
            Head Address (head during interrupt)
            State of the head at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_NR">
            <summary>
            Not Ready (drive not ready or non-existing 2nd head selected)
            Not Ready - When the FDD IS in the not-ready state and a Read or Write command IS Issued, this
             flag IS set If a Read or Write command is issued to side 1 of a single-sided drive, then this flag IS set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_EC">
            <summary>
            Equipment Check (drive failure or recalibrate failed (retry))
            Equipment check - If a fault srgnal IS received from the FDD, or if the track 0 srgnal fails to occur after 77
             step pulses(Recalibrate Command) then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_SE">
            <summary>
            Seek End (Set if seek-command completed)
            Seek end - When the FDC completes the Seek command, this flag IS set lo 1 (high)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_IC0">
            <summary>
            Interrupt Code (low byte)
            Interrupt Code (0=OK, 1=aborted:readfail/OK if EN, 2=unknown cmd
            or senseint with no int occured, 3=aborted:disc removed etc.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR0_IC1">
            <summary>
            Interrupt Code (high byte)
            Interrupt Code (0=OK, 1=aborted:readfail/OK if EN, 2=unknown cmd
            or senseint with no int occured, 3=aborted:disc removed etc.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_MA">
            <summary>
            Missing Address Mark (Sector_ID or DAM not found)
            Missing address mark - This bit is set i f the FDC does not detect the IDAM before 2 index pulses It is also set if
             the FDC cannot find the DAM or DDAM after the IDAM i s found.MD bit of ST2 is also set at this time
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_NW">
            <summary>
            Not Writeable (tried to write/format disc with wprot_tab=on)
            Not writable (write protect) - During execution of Write Data, Write Deleted Data or Write ID command. if the FDC
             detect: a write protect srgnal from the FDD.then this flag is Set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_ND">
            <summary>
            No Data
            No Data (Sector_ID not found, CRC fail in ID_field)
            
            During execution of Read Data. Read Deleted Data Write Data.Write Deleted Data or Scan command, if the FDC cannot find
            the sector specified in the IDR(2)Register, this flag i s set.
            
            During execution of the Read ID command. if the FDC cannot read the ID field without an error, then this flag IS set
            
            During execution of the Read Diagnostic command. if the starting sector cannot be found, then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_OR">
            <summary>
            Over Run (CPU too slow in execution-phase (ca. 26us/Byte))
            Overrun - If the FDC i s not serviced by the host system during data transfers within a certain time interval.this flaa i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_DE">
            <summary>
            Data Error (CRC-fail in ID- or Data-Field)
            Data error - When the FDC detects a CRC(1) error in either the ID field or the data field, this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR1_EN">
            <summary>
            End of Track (set past most read/write commands) (see IC)
            End of cylinder - When the FDC tries to access a sector beyond the final sector of a cylinder, this flag I S set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_MD">
            <summary>
            Missing Address Mark in Data Field (DAM not found)
            Missing address mark - When data IS read from the medium, i f the FDC cannot find a data address mark or deleted 
            data address mark, then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_BC">
            <summary>
            Bad Cylinder (read/programmed track-ID different and read-ID = FF)
            Bad cylinder - This bit i s related to the ND bit. and when the contents of C on the medium is different
            from that stored i n the IDR and the contents  of C IS FFH.then this flag IS set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_SN">
            <summary>
            Scan Not Satisfied (no fitting sector found)
            Scan not satisfied - During execution of the Scan command, i f the F D cannot find a sector on the cylinder 
            which meets the condition.then this flag i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_SH">
            <summary>
            Scan Equal Hit (equal)
            Scan equal hit - During execution of the Scan command. i f the condition of “equal” is satisfied, this flag i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_WC">
            <summary>
            Wrong Cylinder (read/programmed track-ID different) (see b1)
            Wrong cylinder - This bit IS related to the ND bit, and when  the contents of C(3) on the medium is different 
            from that stored i n the IDR.this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_DD">
            <summary>
            Data Error in Data Field (CRC-fail in data-field)
            Data error in data field - If the FDC detects a CRC error i n the data field then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR2_CM">
            <summary>
            Control Mark (read/scan command found sector with deleted DAM)
            Control mark - During execution of the Read Data or Scan command, if the FDC encounters a sector
             which contains a deleted data address mark, this flag is set Also set if DAM is
              found during Read Deleted Data
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_US0">
            <summary>
            Unit select 0
            Unit Select (pin 28,29 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_US1">
            <summary>
            Unit select 1
            Unit Select (pin 28,29 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_HD">
            <summary>
            Head address (side select)
            Head Address (pin 27 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_TS">
            <summary>
            Two Side (0=yes, 1=no (!))
            Two-side - This bit IS used to indicate the status of the two-side signal from the FDD
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_T0">
            <summary>
            Track 0 (on track 0 we are)
            Track 0 - This bit IS used to indicate the status of the track 0 signal from the FDD
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_RY">
            <summary>
            Ready - status of the ready signal from the fdd
            Ready (drive ready signal)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_WP">
            <summary>
            Write Protected (write protected)
            Write protect - status of the wp signal from the fdd
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SR3_FT">
            <summary>
            Fault - This bit is used to indicate the status of the fault signal from the FDD
            Fault (if supported: 1=Drive failure)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.IC_OK">
            <summary>
            1 = aborted:readfail / OK if EN (end of track)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.IC_ABORTED_RF_OKEN">
            <summary>
            1 = aborted:readfail / OK if EN (end of track)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.IC_NO_INT_OCCURED">
            <summary>
            2 = unknown cmd or senseint with no int occured
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.IC_ABORTED_DISCREMOVED">
            <summary>
            3 = aborted:disc removed etc
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command">
            <summary>
            Class that holds information about a specific command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.CommandCode">
            <summary>
            The command code after bitmask has been applied
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.ParameterByteCount">
            <summary>
            The number of bytes that make up the full command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.ResultByteCount">
            <summary>
            The number of result bytes that will be generated from the command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.Direction">
            <summary>
            The command direction
            IN - Z80 to UPD765A
            OUT - UPD765A to Z80
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.MT">
            <summary>
            Command makes use of the MT bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.MF">
            <summary>
            Command makes use of the MF bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.SK">
            <summary>
            Command makes use of the SK bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.IsRead">
            <summary>
            Read/Write command that is READ
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.IsWrite">
            <summary>
            Read/Write command that is WRITE
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Command.CommandDelegate">
            <summary>
            Delegate function that is called by this command
            bool 1: EXECUTE - if TRUE the command will be executed. if FALSE the method will instead parse commmand parameter bytes
            bool 2: RESULT - if TRUE
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters">
            <summary>
            Storage for command parameters
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.UnitSelect">
            <summary>
            The requested drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Side">
            <summary>
            The requested physical side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Cylinder">
            <summary>
            The requested track (C)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Head">
            <summary>
            The requested head (H)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Sector">
            <summary>
            The requested sector (R)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.SectorSize">
            <summary>
            The specified sector size (N)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.EOT">
            <summary>
            The end of track or last sector value (EOT)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Gap3Length">
            <summary>
            Gap3 length (GPL)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.DTL">
            <summary>
            Data length (DTL) - When N is defined as 00, DTL stands for the data length 
            which users are going to read out or write into the sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandParameters.Reset">
            <summary>
            Clear down
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveLight">
            <summary>
            Signs whether the drive is active
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommandList">
            <summary>
            Collection of possible commands
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ActiveCommandParams">
            <summary>
            State parameters relating to the Active command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ActivePhase">
            <summary>
            The current active phase of the controller
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ActiveInterrupt">
            <summary>
            The currently active interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommBuffer">
            <summary>
            Command buffer
            This does not contain the initial command byte (only parameter bytes)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommCounter">
            <summary>
            Current index within the command buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CMD_FLAG_MT">
            <summary>
            Initial command byte flag
            Bit7  Multi Track (continue multi-sector-function on other head)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CMD_FLAG_MF">
            <summary>
            Initial command byte flag
            Bit6  MFM-Mode-Bit (Default 1=Double Density)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CMD_FLAG_SK">
            <summary>
            Initial command byte flag
            Bit5  Skip-Bit (set if secs with deleted DAM shall be skipped)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SRT">
            <summary>
            Step Rate Time (supplied via the specify command)
            SRT stands for the steooino rate for the FDD ( 1 to 16 ms in 1 ms increments). 
            Stepping rate applies to all drives(FH= 1ms, EH= 2ms, etc.).
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SRT_Counter">
            <summary>
            Keeps track of the current SRT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.HUT">
            <summary>
            Head Unload Time (supplied via the specify command)
            HUT stands for the head unload time after a Read or Write operation has occurred 
            (16 to 240 ms in 16 ms Increments)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.HUT_Counter">
            <summary>
            Keeps track of the current HUT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.HLT">
            <summary>
            Head load Time (supplied via the specify command)
            HLT stands for the head load time in the FDD (2 to 254 ms in 2 ms Increments)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.HLT_Counter">
            <summary>
            Keeps track of the current HLT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ND">
            <summary>
            Non-DMA Mode (supplied via the specify command)
            ND stands for operation in the non-DMA mode
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.OverrunCounter">
            <summary>
            In lieu of actual timing, this will count status reads in execution phase
            where the CPU hasnt actually read any bytes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResBuffer">
            <summary>
            Contains result bytes in result phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ExecBuffer">
            <summary>
            Contains sector data to be written/read in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.InterruptResultBuffer">
            <summary>
            Interrupt result buffer
            Persists (and returns when needed) the last result data when a sense interrupt status command happens
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResCounter">
            <summary>
            Current index within the result buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ResLength">
            <summary>
            The byte length of the currently active command
            This may or may not be the same as the actual command resultbytes value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ExecCounter">
            <summary>
            Index for sector data within the result buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ExecLength">
            <summary>
            The length of the current exec command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.LastSectorDataWriteByte">
            <summary>
            The last write byte that was received during execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.LastSectorDataReadByte">
            <summary>
            The last read byte to be sent during execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.LastByteReceived">
            <summary>
            The last parameter byte that was written to the FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SectorDelayCounter">
            <summary>
            Delay for reading sector
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SectorID">
            <summary>
            The phyical sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.IndexPulseCounter">
            <summary>
            Counter for index pulses
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CMDIndex">
            <summary>
            Specifies the index of the currently selected command (in the CommandList)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ActiveCommand">
            <summary>
            The currently active command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.StatusMain">
            <summary>
            Main status register (accessed via reads to port 0x2ffd)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status0">
            <summary>
            Status Register 0
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status1">
            <summary>
            Status Register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status2">
            <summary>
            Status Register 2
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.Status3">
            <summary>
            Status Register 3
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ReadData">
            <summary>
            Read Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ReadDeletedData">
            <summary>
            Read Deleted Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ReadDiagnostic">
            <summary>
            Read Diagnostic (read track)
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDD and FDC. FDC reads all data fields from index hole to EDT
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ReadID">
            <summary>
            Read ID
            COMMAND:    1 parameter byte
            EXECUTION:  The first correct ID information on the cylinder is stored in the data register
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_WriteData">
            <summary>
            Write Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDC and FDD
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_WriteID">
            <summary>
            Write ID (format write)
            COMMAND:    5 parameter bytes
            EXECUTION:  Entire track is formatted
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_WriteDeletedData">
            <summary>
            Write Deleted Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDC and FDD
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ScanEqual">
            <summary>
            Scan Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ScanLowOrEqual">
            <summary>
            Scan Low or Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_ScanHighOrEqual">
            <summary>
            Scan High or Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_Specify">
            <summary>
            Specify
            COMMAND:    2 parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     NO result phase
            
            Looks like specify command returns status 0x80 throughout its lifecycle
            so CB is NOT set
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_Seek">
            <summary>
            Seek
            COMMAND:    2 parameter bytes
            EXECUTION:  Head is positioned over proper cylinder on disk
            RESULT:     NO result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_Recalibrate">
            <summary>
            Recalibrate (seek track 0)
            COMMAND:    1 parameter byte
            EXECUTION:  Head retracted to track 0
            RESULT:     NO result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_SenseInterruptStatus">
            <summary>
            Sense Interrupt Status
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     2 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_SenseDriveStatus">
            <summary>
            Sense Drive Status
            COMMAND:    1 parameter byte
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            
            The ZX spectrum appears to only specify drive 1 as the parameter byte, NOT drive 0
            After the final param byte is received main status changes to 0xd0
            Data register (ST3) result is 0x51 if drive/disk not available
            0x71 if disk is present in 2nd drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_Version">
            <summary>
            Version
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UPD_Invalid">
            <summary>
            Invalid
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ReadMainStatus">
            <summary>
            Called when a status register read is required
            This can be called at any time
            The main status register appears to be queried nearly all the time
            so needs to be kept updated. It keeps the CPU informed of the current state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ReadDataRegister">
            <summary>
            Handles CPU reading from the data register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.WriteDataRegister(System.Byte)">
            <summary>
            Handles CPU writing to the data register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ParseCommandByte(System.Byte)">
            <summary>
            Processes the first command byte (within a command instruction)
            Returns TRUE if successful. FALSE if otherwise
            Called only in idle phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ParseParamByteStandard(System.Int32)">
            <summary>
            Parses the first 5 command argument bytes that are of the standard format
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ClearResultBuffer">
            <summary>
            Clears the result buffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ClearExecBuffer">
            <summary>
            Clears the result buffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommitResultStatus">
            <summary>
            Populates the result status registers
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CommitResultCHRN">
            <summary>
            Populates the result CHRN values
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetPhase_Idle">
            <summary>
            Moves active phase into idle
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetPhase_Result">
            <summary>
            Moves to result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetPhase_Command">
            <summary>
            Moves to command phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetPhase_Execution">
            <summary>
            Moves to execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.FDD_FLAG_MOTOR">
            <summary>
            FDD Flag - motor on/off
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DiskDriveIndex">
            <summary>
            The index of the currently active disk drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ActiveDrive">
            <summary>
            The currently active drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveStates">
            <summary>
            Array that holds state information for each possible drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.FDD_Init">
            <summary>
            Initialization / reset of the floppy drive subsystem
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.GetSector">
            <summary>
            Searches for the requested sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>        
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DiskPointer">
            <summary>
            Returns the disk object from drive 0
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState">
            <summary>
            Holds specfic state information about a drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.ID">
            <summary>
            The drive ID from an FDC perspective
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FLAG_READY">
            <summary>
            Signs whether this drive ready
            TRUE if both drive exists and has a disk inserted
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FLAG_WRITEPROTECT">
            <summary>
            Disk is write protected (TRUE BY DEFAULT)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.SeekCounter">
            <summary>
            Storage for seek steps
            One step for each indexpulse (track index) until seeked track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.SeekStatus">
            <summary>
            Seek status
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.SeekAge">
            <summary>
            Age counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.CurrentSide">
            <summary>
            The current side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.TrackIndex">
            <summary>
            The current track index in the DiskTracks array
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.CurrentTrackID">
            <summary>
            The track ID of the current cylinder
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.SeekingTrack">
            <summary>
            The new track that the drive is seeking to
            (used in seek operations)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.SectorIndex">
            <summary>
            The current sector index in the Sectors array
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.Disk">
            <summary>
            The currently loaded floppy disk
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FDC">
            <summary>
            The parent controller
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FLAG_TRACK0">
            <summary>
            TRUE if we are on track 0
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveState.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>        
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CurrentCPUCycle">
            <summary>
            The current Z80 cycle
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.LastCPUCycle">
            <summary>
            The last CPU cycle when the FDC accepted an IO read/write
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.StatusDelay">
            <summary>
            The current delay figure (in Z80 t-states)
            This implementation only introduces delay upon main status register reads
            All timing calculations should be done during the other read/write operations
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CPUCyclesPerMs">
            <summary>
            Defines the numbers of Z80 cycles per MS
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveClock">
            <summary>
            The floppy drive emulated clock speed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveCyclesPerMs">
            <summary>
            The number of floppy drive cycles per MS
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.StatesPerDriveTick">
            <summary>
            The number of T-States in one floppy drive clock tick
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.TickCounter">
            <summary>
            Responsible for measuring when the floppy drive is ready to run a cycle
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.DriveCycleCounter">
            <summary>
            Internal drive cycle counter
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.TimingInit">
            <summary>
            Initializes the timing routines
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.CheckTiming">
            <summary>
            Called by reads to the main status register
            Returns true if there is no delay
            Returns false if read is to be deferred
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.GetBit(System.Int32,System.Byte)">
            <summary>
            Returns the specified bit value from supplied byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetBit(System.Int32,System.Byte@)">
            <summary>
            Sets the specified bit of the supplied byte to 1
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.UnSetBit(System.Int32,System.Byte@)">
            <summary>
            Sets the specified bit of the supplied byte to 0
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.GetUnitSelect(System.Byte)">
            <summary>
            Returns a drive number (0-3) based on the first two bits of the supplied byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.NECUPD765.SetUnitSelect(System.Int32,System.Byte@)">
            <summary>
            Sets the first two bits of a byte based on the supplied drive number (0-3)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray">
            <summary>
            * Amstrad Gate Array *
            http://www.cpcwiki.eu/index.php/Gate_Array
            https://web.archive.org/web/20170612081209/http://www.grimware.org/doku.php/documentations/devices/gatearray
            http://bread80.com/2021/06/03/understanding-the-amstrad-cpc-video-ram-and-gate-array-subsystem/
            https://cpctech.cpcwiki.de/docs/crtcnew.html
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.FrameEnd">
            <summary>
            True when the frame has ended
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.FrameLength">
            <summary>
            Length of a GA frame in 1MHz clock cycles
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.Z80ClockSpeed">
            <summary>
            Clock speed of the Z80 in Hz
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.GAClockCounter">
            <summary>
            The current GA clock count within the current frame
            Set to -1 at the start of a new frame
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.LastGAFrameClocks">
            <summary>
            Previous frame clock count. Latched at the end of the frame (VSYNC off)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._colourRegisters">
            <summary>
            0-15:   Pen Registers
            16:     Border Colour
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._currentPen">
            <summary>
            The currently selected Pen
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.CPCPalette">
            <summary>
            All CPC colour information
            Based on: https://www.grimware.org/doku.php/documentations/devices/gatearray
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.CPCFirmwarePalette">
            <summary>
            The standard CPC Pallete (ordered by firmware #)
            http://www.cpcwiki.eu/index.php/CPC_Palette
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.CPCHardwarePalette">
            <summary>
            The standard CPC Pallete (ordered by hardware #)
            http://www.cpcwiki.eu/index.php/CPC_Palette
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._screenMode">
            <summary>
            4bit Screen Mode Value
            - Mode 0, 160x200 resolution, 16 colours
            - Mode 1, 320x200 resolution, 4 colours
            - Mode 2, 640x200 resolution, 2 colours
            - Mode 3, 160x200 resolution, 4 colours (undocumented)
            
            When screenmode is updated it will take effect after the next HSync
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.PENR">
            <summary>
            PENR (register 0) - Pen Selection
            This register can be used to select one of the 17 color-registers (pen 0 to 15 or the border). 
            It will remain selected until another PENR command is executed.
            PENR	    Index	
            7	6	5	4	3	2	1	0	color register selected
            0	0	0	0	n   n   n   n   pen n from 0 to 15 (4bits)
            0	0	0	1	x   x   x   x   border
            
            x can be 0 or 1, it doesn't matter
            </summary>     
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.INKR">
            <summary>
            INKR (register 1) - Colour Selection
            This register takes a 5bits parameter which is a color-code. This color-code range from 0 to 31 but there's only 27 differents colors 
            (because the Gate Array use a 3-states logic on the R,G and B signals, thus 3x3x3=27).
            INKR	    Color	
            7	6	5	4	3	2	1	0	
            0	1	0	n   n   n   n   n   where n is a color code (5 bits)
            
            The PEN affected by the INKR command is updated (almost) immediatly
            </summary>     
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.RMR">
            <summary>
            RMR (register 2) - Select screen mode and ROM configuration
            This register control the interrupt counter (reset), the upper and lower ROM paging and the video mode.
            RMR	        Commands
            7	6	5	4	3	2	1	0
            1	0	0	I   UR  LR  VM-->
            
            I   : if set (1), this will reset the interrupt counter
            UR  : Enable (0) or Disable (1) the upper ROM paging (&amp;C000 to &amp;FFFF). You can select which upper ROM with the I/O address &amp;DF00
            LR  : Enable (0) or Disable (1) the lower ROM paging
            VM  : Select the video mode 0,1,2 or 3 (it will take effect after the next HSync)
            </summary>		
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.GA_VSYNC">
            <summary>
            Set when the VSYNC signal is detected from the CRTC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.GA_HSYNC">
            <summary>
            Set when the HSYNC signal is detected from the CRCT
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.C_VSYNC">
            <summary>
            VSYNC signal that is generated by the GA and combined with C_HSYNC before being sent to the CRT
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.C_HSYNC">
            <summary>
            HSYNC signal that is generated by the GA and combined with C_VSYNC before being sent to the CRT
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.C_VSYNC_Black">
            <summary>
            Gatearray is outputting black colour during vsync
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.C_HSYNC_Black">
            <summary>
            Gatearray is outputting black colour during hsync
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.R52">
            <summary>
            GA raster counter incremented at the end of every HSYNC signal from the CRTC
            (interrupt counter)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.V26">
            <summary>
            GA counter that counts the number of HSYNC signals that have been detected during the VSYNC period
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.H06">
            <summary>
            Counts the number of CRTC characters processed during a (CRTC) HSYNC signal
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.IORQA">
            <summary>
            Called when the Z80 acknowledges an interrupt
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.OnHSYNCOn">
            <summary>
            Fired when rising edge of CRTC HSYNC signal is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.OnHSYNCOff">
            <summary>
            Fired when falling edge of CRTC HSYNC signal is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.OnVSYNCOn">
            <summary>
            Fired when CRTC VSYNC active signal is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.OnVSYNCOff">
            <summary>
            Fired when falling edge of CRTC VSYNC signal is detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._xtal">
            <summary>
            16 MHz XTAL crystal that clocks the GA
            We will use this as a 4bit clock counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._videoDataByte1">
            <summary>
            Temporary storage for the first video data byte read from memory
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._videoDataByte2">
            <summary>
            Temporaryy storage for the second video data byte read from memory
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray._videoData">
            <summary>
            Two bytes of video data are read over 16 GA clocks.
            During the following 16 GA clocks, the video data is output to the screen
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.Clock">
            <summary>
            Gate array is clocked at 16MHz (which is also the pixel clock)
            It implements a 4-phase clock that is in charge of clocking the following devices:
            
            * CPU:		4MHz (4 GA clocks per z80 PHI clock)
            * CRTC:		1MHz (16 GA clocks per CRTC clock)
            * PSG:		1MHz (16 GA clocks per PSG clock)
            
            Regardless of screen mode, the GA will output a single pixel every 1 GA clock (so a 16MHz pixel clock)
            It constantly reads video data at 2MHz (8 GA clocks per byte)
            
            So:
            - 16 GA clocks (1MHz) takes 1 microsecond, one CRTC character
            - 8 GA clocks (2MHz) takes 0.5 microseconds, a byte of video data is read and 8 pixels are output
            - So each CRTC character is 16 pixels wide
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.MAX_SCR_CHA_WIDTH">
            <summary>
            CPC always has a 64 character total width (including HSYNC and VSYNC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.MAX_SCREEN_SCANLINES">
            <summary>
            Maximum number of scanlines on the screen (including HSYNC and VSYNC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.PIXEL_WIDTH_PER_CHAR">
            <summary>
            16 pixels per character, each pixel is output at 16MHz - so each CRTC character is 1 microsecond
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.MAX_SCREEN_WIDTH_PIXELS">
            <summary>
            Maximum screen width in pixels
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArray.TOTAL_DISPLAY_SCANLINES">
            <summary>
            Beam renders 2 scanlines at a time
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData">
            <summary>
            Data structure for holding
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.IndexFirmware">
            <summary>
            CPC Firmware Index (also defines the green screen luminosity)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.IndexHardware">
            <summary>
            CPC Hardware Index
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.IndexINKR">
            <summary>
            CPC Hardware Palette Index (the INKR number)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.IndexASIC">
            <summary>
            12-bit ASIC index value
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.Red">
            <summary>
            RED channel percentage
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.Green">
            <summary>
            GREEN channel percentage
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.Blue">
            <summary>
            BLUE channel percentage
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.ARGB">
            <summary>
            .NET ARGB value
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.C_VSYNC">
            <summary>
            Composite VSYNC - set when CSYNC is pulsed
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCColourData.C_HSYNC">
            <summary>
            Composite HSYNC - set when CSYNC is pulsed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.StandardKeyboard">
            <summary>
            The 48k keyboard device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.StandardKeyboard.ReadCurrentLine">
            <summary>
            Reads the currently selected line
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.StandardKeyboard.GetKeyIndexFromMatrix(System.String)">
            <summary>
            Returns the index of the key within the matrix
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.StandardKeyboard.SetKeyStatus(System.String,System.Boolean)">
            <summary>
            Sets key status
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.StandardKeyboard.GetKeyStatus(System.String)">
            <summary>
            Gets a key's status
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.LibFz80Wrapper.Pins">
            <summary>
            Z80 pin configuration
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.LibFz80Wrapper.IRQACK_Callbacks">
            <summary>
            Fired when the CPU acknowledges an interrupt
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.PAL16L8">
            <summary>
            Programmable Array Logic (PAL) device
            The C6128's second page of 64KB of RAM is controlled by this chip
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PAL16L8.MMR">
            <summary>
            PAL MMR Register
            This register exists only in CPCs with 128K RAM (like the CPC 6128, or CPCs with Standard Memory Expansions)
            Note: In the CPC 6128, the register is a separate PAL that assists the Gate Array chip
            
            Bit	Value	Function
            7	1	    MMR register enable
            6	1		MMR register enable
            5	b	    64K bank number(0..7); always 0 on an unexpanded CPC6128, 0-7 on Standard Memory Expansions
            4	b
            3	b
            2	x       RAM Config(0..7)
            1	x       ""  
            0	x       ""
            
            The 3bit RAM Config value is used to access the second 64K of the total 128K RAM that is built into the CPC 6128 or the additional 64K-512K of standard memory expansions. 
            These contain up to eight 64K ram banks, which are selected with bit 3-5. A standard CPC 6128 only contains bank 0. Normally the register is set to 0, so that only the 
            first 64K RAM are used (identical to the CPC 464 and 664 models). The register can be used to select between the following eight predefined configurations only:
            
            -Address-   0       1       2       3       4       5       6       7
            0000-3FFF   RAM_0   RAM_0   RAM_4   RAM_0   RAM_0   RAM_0   RAM_0   RAM_0
            4000-7FFF   RAM_1   RAM_1   RAM_5   RAM_3   RAM_4   RAM_5   RAM_6   RAM_7
            8000-BFFF   RAM_2   RAM_2   RAM_6   RAM_2   RAM_2   RAM_2   RAM_2   RAM_2
            C000-FFFF   RAM_3   RAM_7   RAM_7   RAM_7   RAM_3   RAM_3   RAM_3   RAM_3
            
            The Video RAM is always located in the first 64K, VRAM is in no way affected by this register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255">
            <summary>
            Emulates the PPI (8255) chip
            http://www.cpcwiki.eu/imgs/d/df/PPI_M5L8255AP-5.pdf
            http://www.cpcwiki.eu/index.php/8255
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.BDIR">
            <summary>
            BDIR Line connected to PSG
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.BC1">
            <summary>
            BC1 Line connected to PSG
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.Regs">
            <summary>
            The i8255 internal data registers
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.DirPortA">
            <summary>
            Returns the currently latched port direction for Port A
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.DirPortB">
            <summary>
            Returns the currently latched port direction for Port B
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.DirPortCL">
            <summary>
            Returns the currently latched port direction for Port C (lower half)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.DirPortCU">
            <summary>
            Returns the currently latched port direction for Port C (upper half)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.OUTPortA(System.Int32)">
            <summary>
            Writes to Port A
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.OUTPortB(System.Int32)">
            <summary>
            Writes to Port B
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.OUTPortC(System.Int32)">
            <summary>
            Writes to Port C
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.OUTControl(System.Int32)">
            <summary>
            Writes to the control register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.INPortA">
            <summary>
            Reads from Port A
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.INPortB">
            <summary>
            Reads from Port B
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.INPortC">
            <summary>
            Reads from Port C
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.PPI_8255.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen">
            <summary>
            Basic emulation of a PAL Amstrad CPC CRT screen
            
            Decoding of C-SYNC pulses are not emulated properly, 
            we just assume that so long as the C-VSYNC and C-HSYNC periods are correct, the screen will display.
            
            References used:
            - https://www.cpcwiki.eu/index.php/GT64/GT65
            - https://www.cpcwiki.eu/index.php/CTM640/CTM644
            - https://martin.hinner.info/vga/pal.html
            - https://uzebox.org/forums/viewtopic.php?t=11062
            - https://www.cpcwiki.eu/forum/emulators/wish-60hz60fps-support-in-emulators-thought-on-emulating-a-crt/
            - https://www.batsocks.co.uk/readme/video_timing.htm
            - https://web.archive.org/web/20170202185019/https://www.retroleum.co.uk/PALTVtimingandvoltages.html
            - https://web.archive.org/web/20131125145905/http://lipas.uwasa.fi/~f76998/video/modes/
            - https://cpcrulez.fr/coding_grimware-the_mighty_crtc_6845.htm
            - https://www.monitortests.com/blog/timing-parameters-explained/
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.ScreenType">
            <summary>
            The type of monitor to emulate
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.FrameEnd">
            <summary>
            Checked and reset in the emulator loop. If true, framend processing happens
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.LINE_PERIOD">
            <summary>
            Total line period in microseconds
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.TOTAL_PIXELS">
            <summary>
            Total horizontal time in pixels
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.FRAMEBUFFER_MAX_WIDTH">
            <summary>
            Arbirary processing buffer width
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.TOTAL_LINES">
            <summary>
            Total scanlines per frame
            This is:
            - 625 in interlaced mode (25Hz)
            - 312 in non-interlaced mode (50.08Hz)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.PIXEL_TIME">
            <summary>
            The number or pixels being rendered every microsecond
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen._gunPosH">
            <summary>
            X position of the electron gun (inluding sync areas)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen._timePosH">
            <summary>
            Position in frame time on the X-axis
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen._gunPosV">
            <summary>
            Y position of the electron gun (inluding sync areas)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen._timePosV">
            <summary>
            Position in frame time on the V-Axis
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen.VideoClock(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Should be called at the pixel clock rate (in the case of the Amstrad CPC, 16MHz)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CRTScreen._frameBuffer">
            <summary>
            Working buffer that encapsulates the entire PAL frame time
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.ScreenType">
            <summary>
            The type of Amstrad CRT to emulate
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.ScreenType.CTM064x">
            <summary>
            CTM640/CTM644
            Amstrad colour monitors
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.ScreenType.GT6x">
            <summary>
            GT64/GT65/GT65-2
            Amstrad green screen monitors
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464">
            <summary>
            CPC464 construction
            </summary>
            <summary>
            CPC464
            * Memory *
            </summary>
            <summary>
            CPC464
            * Port *
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.#ctor(BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC,BizHawk.Emulation.Cores.Computers.AmstradCPC.LibFz80Wrapper,System.Collections.Generic.List{System.Byte[]},System.Boolean,BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.BorderType)">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus
            ROM paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus
            Writes to the bus ALWAYS go to RAM, regardless of what upper and lower ROMs are paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.InitROM(BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData[])">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC464.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            Because of the port decoding, multiple devices can be written to
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128">
            <summary>
            CPC6128 construction
            </summary>
            <summary>
            CPC6128
            * Memory *
            </summary>
            <summary>
            CPC6128
            * Port *
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.#ctor(BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC,BizHawk.Emulation.Cores.Computers.AmstradCPC.LibFz80Wrapper,System.Collections.Generic.List{System.Byte[]},System.Boolean,BizHawk.Emulation.Cores.Computers.AmstradCPC.AmstradCPC.BorderType)">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus
            ROM and RAM paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus
            Writes to the bus ALWAYS go to RAM, regardless of what upper and lower ROMs are paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.InitROM(BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData[])">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPC6128.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            Because of the port decoding, multiple devices can be written to
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase">
            <summary>
            The abstract class that all emulated models will inherit from
            * Main properties / fields / contruction*
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Input *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Imported media *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Memory *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Port Access *
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.CPC">
            <summary>
            The calling AmstradCPC class (piped in via constructor)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.RomData">
            <summary>
            ROM and extended info
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.TapeDevice">
            <summary>
            The Amstrad datacorder device
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.TapeBuzzer">
            <summary>
            beeper output for the tape
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.AYDevice">
            <summary>
            Device representing the AY-3-8912 chip found in the CPC
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.KeyboardDevice">
            <summary>
            The keyboard device
            Technically, this is controlled by the PSG, but has been abstracted due to the port over from ZXHawk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.UPDDiskDevice">
            <summary>
            The Amstrad disk drive
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.CRTC">
            <summary>
            The Cathode Ray Tube Controller chip
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.GateArray">
            <summary>
            The Amstrad gate array
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.CRTScreen">
            <summary>
            The CRT screen
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.PPI">
            <summary>
            The PPI contoller chip
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.PAL">
            <summary>
            PAL16L8 Programmable Logic Array Circuit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.FrameLength">
            <summary>
            The length of a standard frame in CPU cycles
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.FrameCompleted">
            <summary>
            Signs whether the frame has ended
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.FrameCount">
            <summary>
            The total number of frames rendered
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase._frameCycles">
            <summary>
            The current cycle (T-State) that we are at in the frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.LastFrameStartCPUTick">
            <summary>
            Stores where we are in the frame after each CPU cycle
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.CurrentFrameCycle">
            <summary>
            Gets the current frame cycle according to the CPU tick count
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase._render">
            <summary>
            Non-Deterministic bools
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.BORDER_BIT">
            <summary>
            Mask constants &amp; misc
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ExecuteFrame(System.Boolean,System.Boolean)">
            <summary>
            Executes a single frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.HardReset">
            <summary>
            Hard reset of the emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.SoftReset">
            <summary>
            Soft reset of the emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.PollInput">
            <summary>
            Cycles through all the input callbacks
            This should be done once per frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.inputRead">
            <summary>
            Signs whether input read has been requested
            This forms part of the IEmulator LagFrame implementation
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.mediaImages">
            <summary>
            The tape or disk image(s) that are passed in from the main AmstradCPC class
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.tapeImages">
            <summary>
            Tape images
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.diskImages">
            <summary>
            Disk images
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.tapeMediaIndex">
            <summary>
            The index of the currently 'loaded' tape image
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.diskMediaIndex">
            <summary>
            The index of the currently 'loaded' disk image
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.InitializeMedia(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Called on first instantiation (and subsequent core reboots)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.LoadAllMedia">
            <summary>
            Attempts to load all media into the relevant structures
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.LoadTapeMedia">
            <summary>
            Attempts to load a tape into the tape device based on tapeMediaIndex
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.LoadDiskMedia">
            <summary>
            Attempts to load a disk into the disk device based on diskMediaIndex
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.IdentifyMedia(System.Byte[])">
            <summary>
            Identifies and sorts the various media types
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ROMLower">
            <summary>
            Lower: OS ROM
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ROM0">
            <summary>
            Upper: POS 0 (usually BASIC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ROM7">
            <summary>
            Upper: POS 7 (usually AMSDOS)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.UpperROMPaged">
            <summary>
            Signs whether Upper ROM is paged in
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.UpperROMPosition">
            <summary>
            The position of the currently paged upper ROM
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.LowerROMPaged">
            <summary>
            Signs whether Lower ROM is paged in
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.RAMConfig">
            <summary>
            The currently selected RAM config
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.RAM64KBank">
            <summary>
            Always 0 on a CPC6128
            On a machine with more than 128K RAM (standard memory expansion) this selects each additional 64K above the first upper 64K
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.PushBus">
            <summary>
             Pushes a value onto the data bus that should be valid as long as the interrupt is true
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.InitROM(BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData[])">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.FetchScreenMemory(System.UInt16)">
            <summary>
            Gate Array reads the memory at the specified address
            (No memory contention)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.DecodeINPort(System.UInt16)">
            <summary>
            Returns a single port device enum based on the port address
            (for IN operations)
            https://web.archive.org/web/20090808085929/http://www.cepece.info/amstrad/docs/iopord.html
            http://www.cpcwiki.eu/index.php/I/O_Port_Summary
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.DecodeOUTPort(System.UInt16)">
            <summary>
            Returns a list of port device enums based on the port address
            (for OUT operations)
            https://web.archive.org/web/20090808085929/http://www.cepece.info/amstrad/docs/iopord.html
            http://www.cpcwiki.eu/index.php/I/O_Port_Summary
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCBase.PortDevice">
            <summary>
            Potential port devices
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.MachineType">
            <summary>
            The various CPC models CPCHawk emulates
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.MachineType.CPC464">
            <summary>
            Original Amstrad CPC model with builtin datacorder
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.MachineType.CPC6128">
            <summary>
            128K model with builtin 3" disk drive
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCExtendedFloppyDisk">
            <summary>
            Logical object representing a standard +3 disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCExtendedFloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCExtendedFloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCExtendedFloppyDisk.SplitDoubleSided(System.Byte[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Takes a double-sided disk byte array and converts into 2 single-sided arrays
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCExtendedFloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCFloppyDisk">
            <summary>
            Logical object representing a standard +3 disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCFloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCFloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data 
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCFloppyDisk.SplitDoubleSided(System.Byte[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Takes a double-sided disk byte array and converts into 2 single-sided arrays
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CPCFloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.DiskHandler">
            <summary>
            This is called first when importing disk images
            Disk images can be single or double-sided, so we need to handle that
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.DiskType">
            <summary>
            The different disk formats CPCHawk currently supports
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DiskType.CPC">
            <summary>
            Standard CPCEMU disk format (used in the built-in +3 disk drive)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.DiskType.CPCExtended">
            <summary>
            Extended CPCEMU disk format (used in the built-in +3 disk drive)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk">
            <summary>
            This abstract class defines a logical floppy disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DiskFormatType">
            <summary>
            The disk format type
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DiskHeader">
            <summary>
            Disk information header
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DiskTracks">
            <summary>
            Track array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.CylinderCount">
            <summary>
            No. of tracks per side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.SideCount">
            <summary>
            The number of physical sides
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.BytesPerTrack">
            <summary>
            The number of bytes per track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.WriteProtected">
            <summary>
            The write-protect tab on the disk
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.Protection">
            <summary>
            The detected protection scheme (if any)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DiskData">
            <summary>
            The actual disk image data
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DirtyData">
            <summary>
            If TRUE then data on the disk has changed (been written to)
            This will be used to determine whether the disk data needs to be included
            in any SyncState operations
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.RandomCounter">
            <summary>
            Used to deterministically choose a 'random' sector when dealing with weak reads
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.ParseProtection">
            <summary>
            Examines the floppydisk data to work out what protection (if any) is present
            If possible it will also fix the disk data for this protection
            This should be run at the end of the ParseDisk() method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DetectShadowOfTheBeast">
            <summary>
            Detection routine for shadow of the beast game
            Still cannot get this to work, but at least the game is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DetectSpeedlock(System.Int32[]@)">
            <summary>
            Detect speedlock weak sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DetectAlkatraz(System.Int32[]@)">
            <summary>
            Detect Alkatraz
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DetectPaulOwens(System.Int32[]@)">
            <summary>
            Detect Paul Owens
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.DetectHexagon(System.Int32[]@)">
            <summary>
            Detect Hexagon copy protection
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.GetTrackCount">
            <summary>
            Returns the track count for the disk
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.ReadID(System.Byte,System.Byte,System.Int32)">
            <summary>
            Reads the current sector ID info
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization routines
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.FloppyDisk.Track.TrackSectorData">
            <summary>
            Presents a contiguous byte array of all sector data for this track
            (including any multiple weak/random data)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.ProtectionType">
            <summary>
            Defines the type of speedlock detection found
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter">
            <summary>
            Abtract class that represents all Media Converters
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.FormatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.Read(System.Byte[])">
            <summary>
            Serialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.Write(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.CheckType(System.Byte[])">
            <summary>
            Serializer does a quick check, returns TRUE if file is detected as this type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.GetBytes(System.Int32)">
            <summary>
            Converts an int32 value into a byte array
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.GetInt32(System.Byte[],System.Int32)">
            <summary>
            Returns an int32 from a byte array based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.GetWordValue(System.Byte[],System.Int32)">
            <summary>
            Returns an uint16 from a byte array based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.SetWordValue(System.Byte[],System.Int32,System.UInt16)">
            <summary>
            Updates a byte array with a uint16 value based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.TranslatePause(System.Int32)">
            <summary>
            Takes a PauseInMilliseconds value and returns the value in T-States
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverter.DecompressZRLE(System.Byte[],System.Byte[]@)">
            <summary>
            Decompresses a byte array that is Z-RLE compressed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.MediaConverterType">
            <summary>
            Represents the different types of media serializer avaiable
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter">
            <summary>
            Responsible for TZX format serialization
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter._blocks">
            <summary>
            Working list of generated tape data blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter._position">
            <summary>
            Position counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter._loopCounter">
            <summary>
            Object to keep track of loops - this assumes there is only one loop at a time
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.ConvertClock(BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock)">
            <summary>
            CDT format is essentially exactly the same as the TZX format
            However all timings are based on spectrum timings (3.5Mhz)
            so need to be adjusted for the CPC (4Mhz)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.CheckType(System.Byte[])">
            <summary>
            Returns TRUE if tzx header is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.ProcessBlock(System.Byte[],System.Int32)">
            <summary>
            Processes a TZX block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.DecodeDataBlock(BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock,System.Byte[],BizHawk.Emulation.Cores.Computers.AmstradCPC.DataBlockType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to process either a standard or turbo data block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.DecodeDataBlock(BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock,System.Byte[],BizHawk.Emulation.Cores.Computers.AmstradCPC.DataBlockType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to process either a standard or turbo data block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.CdtConverter.CreatePauseBlock(BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock)">
            <summary>
            If necessary a separate PAUSE block will be created
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeCommand">
            <summary>
            Represents the possible commands that can be raised from each tape block
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock">
            <summary>
            Represents a tape block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock._blockID">
            <summary>
            Either the TZX block ID, or -1 in the case of non-tzx blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock._blockType">
            <summary>
            The block type
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock._blockData">
            <summary>
            Byte array containing the raw block data
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.MetaData">
            <summary>
            Dictionary of block related data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.AddMetaData(BizHawk.Emulation.Cores.Computers.AmstradCPC.BlockDescriptorTitle,System.String)">
            <summary>
            Adds a single metadata item to the Dictionary
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.DataPeriods">
            <summary>
            List containing the pulse timing values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock._command">
            <summary>
            Command that is raised by this data block
            (that may or may not need to be acted on)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock._pauseInMS">
            <summary>
            The defined post-block pause
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.GetDataPeriodsArray">
            <summary>
            Returns the data periods as an array
            (primarily to aid in bizhawk state serialization)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.SetDataPeriodsArray(System.Int32[])">
            <summary>
            Accepts an array of data periods and updates the DataPeriods list accordingly
            (primarily to aid in bizhawk state serialization)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.TapeDataBlock.SyncState(BizHawk.Common.Serializer,System.Int32)">
            <summary>
            Bizhawk state serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.BlockType">
            <summary>
            The types of TZX blocks
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.BlockDescriptorTitle">
            <summary>
            Different title possibilities
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData">
            <summary>
            Information about Amstrad ROM
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData.RomBytes">
            <summary>
            ROM Contents
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData.ROMType">
            <summary>
            Whether this is an Upper or Lower ROM
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData.ROMPosition">
            <summary>
            The designated ROM position for this ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData.InitROM(BizHawk.Emulation.Cores.Computers.AmstradCPC.MachineType,System.Byte[],BizHawk.Emulation.Cores.Computers.AmstradCPC.RomData.ROMChipType,System.Int32)">
            <summary>
            Initialise a RomData object
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AmstradCPC.SoundProviderMixer">
            <summary>
            My attempt at mixing multiple ISoundProvider sources together and outputting another ISoundProvider
            Currently only supports SyncSoundMode.Sync
            Attached ISoundProvider sources must already be stereo 44.1khz and ideally sound buffers should be the same length (882)
            (if not, only 882 samples of their buffer will be used)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArrayType.Amstrad40007">
            <summary>
            CPC 464
            The first version of the Gate Array is the 40007 and was released with the CPC 464
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArrayType.Amstrad40008">
            <summary>
            CPC 664
            Later, the CPC 664 came out fitted with the 40008 version (and at the same time, the CPC 464 was also upgraded with this version). 
            This version is pinout incompatible with the 40007 (that's why the upgraded 464 of this period have two Gate Array slots on the motherboard, 
            one for a 40007 and one for a 40008)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArrayType.Amstrad40010">
            <summary>
            CPC 6128
            The CPC 6128 was released with the 40010 version (and the CPC 464 and 664 manufactured at that time were also upgraded to this version). 
            The 40010 is pinout compatible with the previous 40008
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArrayType.Amstrad40226">
            <summary>
            Costdown CPC
            In the last serie of CPC 464 and 6128 produced by Amstrad in 1988, a small ASIC chip have been used to reduce the manufacturing costs. 
            This ASIC emulates the Gate Array, the PAL and the CRTC 6845. And no, there is no extra features like on the Amstrad Plus. 
            The only noticeable difference seems to be about the RGB output levels which are not exactly the same than those produced with a real Gate Array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.AmstradCPC.GateArrayType.Amstrad40489">
            <summary>
            Plus &amp; GX-4000
            All the Plus range is built upon a bigger ASIC chip which is integrating many features of the classic CPC (FDC, CRTC, PPI, Gate Array/PAL) and all 
            the new Plus specific features. The Gate Array on the Plus have a new register, named RMR2, to expand the ROM mapping functionnalities of the machine. 
            This register requires to be unlocked first to be available. And finally, the RGB levels produced by the ASIC on the Plus are noticeably differents
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AppleII.Components">
            <summary>
            A container class for the individual machine components
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AppleII.EmptyCassetteComponent">
            <summary>
            An empty implementation of ICassette, since we have not current built cassette functionality
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AppleII.EmptyPeripheralCard">
            <summary>
            Represents an unused peripheral card
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.AppleII.GamePortComponent">
            <summary>
            Currently a default implementation of the GamePort, needs to be built for gamepad support
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.Commodore64.Motherboard">
            <summary>
            Contains the onboard chipset and glue.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.Am29F040B">
            <summary>
            AMD flash chip used for EasyFlash emulation.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.Am29F040B.SyncState(BizHawk.Common.Serializer,System.Boolean)">
            <summary>
            Synchronize state.
            </summary>
            <param name="ser">
            State serializer.
            </param>
            <param name="withData">
            True only if the raw data should be synchronized. If false,
            the caller is responsible for synchronizing deltas.
            </param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.CartridgeChip.ConvertDataToBytes">
            <summary>
            This exists to bridge the gap between the old int[] representation
            and the new byte[] representation of <see cref="F:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.CartridgeChip.Data"/>.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.Mapper0020">
             <summary>
             Implements the EasyFlash cartridge format.
            
             The most common EasyFlash implementation uses 2x AM29F040 programmable ROMs
             and a 256-byte memory.
            
             The address bus is 19 bits wide. Bits 18-13 are set by the "bank"
             register (implemented as a separate bank of flip-flops on the board) and
             bits 12-0 are set from the system bus. "RomH" and "RomL" are directly
             tied to the respective chip-enable signals for each flash ROM, which means
             that address range $8000-$9FFF will correspond to one flash ROM, and $A000-$BFFF
             (or $E000-$FFFF in UltiMax configuration) will correspond to the other.
            
             Control registers are mapped to $DE00 and $DE02. The 256-byte RAM is mapped to $DF00-$DFFF.
             </summary>
             <remarks>
             Two registers can be accessed:
            
             $DE00 - bank register (bits: 00BBBBBB)
             B = bank ($00-$3F)
            
             $DE02 - control register (bits: L0000MXG)
             L = light control
             M = Game pin control; 1=software controlled, 0=onboard jumper controlled
             X = ExRom pin level; 1=low, 0=high
             G = Game pin level; 1=low, 0=high
             </remarks>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Cartridge.Mapper0020.StoreSaveRam(System.Byte[])">
            <summary>
            Applies a SaveRam block to the flash memory.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.Disk.#ctor(System.Int32)">
            <summary>
            Create a blank, unformatted disk.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.Disk.#ctor(System.Collections.Generic.IList{System.Byte[]},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            Create an expanded representation of a magnetic disk.
            </summary>
            <param name="trackData">Raw bit data.</param>
            <param name="trackNumbers">Track numbers for the raw bit data.</param>
            <param name="trackDensities">Density zones for the raw bit data.</param>
            <param name="trackCapacity">Total number of tracks on the media.</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack">
            <summary>
            Represents the magnetic flux transitions for one rotation of floppy disk media. Each bit represents
            the transition of the signal level from 1 to 0, or from 0 to 1.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.ClockRateHz">
            <summary>
            The master clock rate for synchronization.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.BytesPerEntry">
            <summary>
            Number of bytes per element in the Bits array.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.FluxBitsPerEntry">
            <summary>
            Number of bits contained in a single value of the Bits array.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.FluxBitsPerTrack">
            <summary>
            The number of flux transition bits stored for each track.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.FluxEntriesPerTrack">
            <summary>
            The fixed size of the Bits array.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Bits">
            <summary>
            Current state of the disk, which may be changed from the original media.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Original">
            <summary>
            Fixed state of the original media, from which deltas will be calculated.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Clone">
            <summary>
            Create a clone of the DiskTrack.
            </summary>
            <returns>
            A new DiskTrack with an identical copy of <see cref="P:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Bits"/>.
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.IsModified">
            <summary>
            Check to see if the original bits and current bits are equivalent.
            </summary>
            <returns>
            True only if the content differs.
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Reset">
            <summary>
            Resets this track to the state of the original media.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Write(System.Int32,System.Int32)">
            <summary>
            Write an entry to <see cref="P:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Bits"/>.
            </summary>
            <param name="index">
            Index of the entry to write.
            </param>
            <param name="bits">
            The new content of the entry.
            </param>
            <returns>
            True only if data in <see cref="P:BizHawk.Emulation.Cores.Computers.Commodore64.Media.DiskTrack.Bits"/> has been altered.
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.MOS.Via.ExecutePhase">
            <summary>
            Execute one full phase of VIA logic.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Serial.Drive1541.ResetDeltas">
            <summary>
            Clear all cached deltas.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Serial.Drive1541.SaveDeltas">
            <summary>
            Calculate and cache the deltas for each track on the current disk.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.Commodore64.Serial.Drive1541.LoadDeltas">
            <summary>
            Apply new deltas for each track on the current disk.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.MSX.LibMSX">
            <summary>
            static bindings into MSXHawk.dll
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_create">
            <returns>opaque state pointer</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_destroy(System.IntPtr)">
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_load_bios(System.IntPtr,System.Byte[],System.Byte[])">
            <summary>
            Load BIOS and BASIC image. each must be 16K in size
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="bios">the rom data, can be disposed of once this function returns</param>
            <param name="basic">length of romdata in bytes</param>
            <returns>0 on success, negative value on failure.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_load(System.IntPtr,System.Byte[],System.UInt32,System.Int32,System.Byte[],System.UInt32,System.Int32)">
            <summary>
            Load ROM image.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="romdata_1">the rom data, can be disposed of once this function returns</param>
            <param name="length_1">length of romdata in bytes</param>
            <param name="mapper_1">Mapper number to load core with</param>
            <param name="romdata_2">the rom data, can be disposed of once this function returns</param>
            <param name="length_2">length of romdata in bytes</param>
            <param name="mapper_2">Mapper number to load core with</param>
            <returns>0 on success, negative value on failure.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_frame_advance(System.IntPtr,System.Byte,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Advance a frame and send controller data.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="ctrl1">controller data for player 1</param>
            <param name="ctrl2">controller data for player 2</param>
            <param name="render">length of romdata in bytes</param>
            <param name="sound">Mapper number to load core with</param>
            <returns>0 on success, negative value on failure.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_get_video(System.IntPtr,System.Int32[])">
            <summary>
            Get Video data
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="videobuf">where to send video to</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_get_audio(System.IntPtr,System.Int32[],System.UInt32@)">
            <summary>
            Get Video data
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="aud_buf">where to send left audio to</param>
            <param name="n_samp">number of left samples</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getmessagelength(System.IntPtr)">
            <summary>
            get messages length
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getmessage(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            get messages from the core
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="h">pointer to const char *</param>
            <param name="l">length of message to fetch</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_save_state(System.IntPtr,System.Byte[])">
            <summary>
            Save State
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="saver">save buffer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_load_state(System.IntPtr,System.Byte[])">
            <summary>
            Load State
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="loader">load buffer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getsysbus(System.IntPtr,System.Int32)">
            <summary>
            Read the system bus
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">system bus address</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getvram(System.IntPtr,System.Int32)">
            <summary>
            Read the VRAM
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">vram address</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getram(System.IntPtr,System.Int32)">
            <summary>
            Read the RAM
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">ram address</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.TraceCallback">
            <summary>
            type of the cpu trace callback
            </summary>
            <param name="t">type of event</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_settracecallback(System.IntPtr,BizHawk.Emulation.Cores.Computers.MSX.LibMSX.TraceCallback)">
            <summary>
            set a callback for trace logging
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getheaderlength(System.IntPtr)">
            <summary>
            get the trace logger header length
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getdisasmlength(System.IntPtr)">
            <summary>
            get the trace logger disassembly length, a constant
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getregstringlength(System.IntPtr)">
            <summary>
            get the trace logger register string length, a constant
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getheader(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            get the trace logger header
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="h">pointer to const char *</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getregisterstate(System.IntPtr,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            get the register state from the cpu
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="h">pointer to const char *</param>
            <param name="t">call type</param>
            <param name="l">copy length, must be obtained from appropriate get legnth function</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.MSX.LibMSX.MSX_getdisassembly(System.IntPtr,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            get the register state from the cpu
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="h">pointer to const char *</param>
            <param name="t">call type</param>
            <param name="l">copy length, must be obtained from appropriate get legnth function</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IBeeperDevice">
            <summary>
            Represents a beeper/buzzer device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IBeeperDevice.Init(System.Int32,System.Int32)">
            <summary>
            Initialisation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IBeeperDevice.ProcessPulseValue(System.Boolean)">
            <summary>
            Processes an incoming pulse value and adds it to the blipbuffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IBeeperDevice.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IFDDHost">
            <summary>
            Defines an object that can load a floppy disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IFDDHost.Disk">
            <summary>
            The currently inserted diskimage
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IFDDHost.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IFDDHost.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IFDDHost.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>   
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick">
            <summary>
            Represents a spectrum joystick
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick.JoyType">
            <summary>
            The type of joystick
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick.ButtonCollection">
            <summary>
            Array of all the possibly button press names
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick.PlayerNumber">
            <summary>
            The player number that this controller is currently assigned to
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IJoystick.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard">
            <summary>
            Represents a spectrum keyboard
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard._machine">
            <summary>
            The calling spectrumbase class
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.KeyboardMatrix">
            <summary>
            The keyboard matrix for a particular spectrum model
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.NonMatrixKeys">
            <summary>
            Other keyboard keys that are not in the matrix
            (usually keys derived from key combos)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.KeyLine">
            <summary>
            Represents the spectrum key state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.ResetLineStatus">
            <summary>
            Resets the line status
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.IsIssue2Keyboard">
            <summary>
            There are some slight differences in how PortIN and PortOUT functions
            between Issue2 and Issue3 keyboards (16k/48k spectrum only)
            It is possible that some very old games require Issue2 emulation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.SetKeyStatus(System.String,System.Boolean)">
            <summary>
            Sets the spectrum key status
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.GetKeyStatus(System.String)">
            <summary>
            Gets the status of a spectrum key
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.GetLineStatus(System.Byte)">
            <summary>
            Returns the query byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.ReadKeyboardByte(System.UInt16)">
            <summary>
            Reads a keyboard byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IKeyboard.GetByteFromKeyMatrix(System.String)">
            <summary>
            Looks up a key in the keyboard matrix and returns the relevent byte value
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPortIODevice">
            <summary>
            Represents a device that utilizes port IN &amp; OUT
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPortIODevice.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPortIODevice.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG">
            <summary>
            Represents a PSG device (in this case an AY-3-891x)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.Init(System.Int32,System.Int32)">
            <summary>
            Initlization routine
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.SelectedRegister">
            <summary>
            Activates a register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.PortWrite(System.Int32)">
            <summary>
            Writes to the PSG
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.PortRead">
            <summary>
            Reads from the PSG
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.Reset">
            <summary>
            Resets the PSG
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.Volume">
            <summary>
            The volume of the AY chip
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.StartFrame">
            <summary>
            Called at the start of a frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.EndFrame">
            <summary>
            called at the end of a frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.UpdateSound(System.Int32)">
            <summary>
            Updates the sound based on number of frame cycles
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPSG.SyncState(BizHawk.Common.Serializer)">
            <summary>
            IStatable serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice">
            <summary>
            Represents the tape device (or build-in datacorder as it was called +2 and above)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.Init(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase)">
            <summary>
            Initializes the datacorder device
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.counter">
            <summary>
            Internal counter used to trigger tape buzzer output
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._currentDataBlockIndex">
            <summary>
            The index of the current tape data block that is loaded
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._position">
            <summary>
            The current position within the current data block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._tapeIsPlaying">
            <summary>
            Signs whether the tape is currently playing or not
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._dataBlocks">
            <summary>
            A list of the currently loaded data blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._lastCycle">
            <summary>
            Stores the last CPU t-state value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._waitEdge">
            <summary>
            Edge
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.currentState">
            <summary>
            Current tapebit state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice._autoPlay">
            <summary>
            Signs whether the device should autodetect when the Z80 has entered into
            'load' mode and auto-play the tape if neccesary
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.EndFrame">
            <summary>
            Should be fired at the end of every frame
            Primary purpose is to detect tape traps and manage auto play
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.Play">
            <summary>
            Starts the tape playing from the beginning of the current block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.Stop">
            <summary>
            Stops the tape
            (should move to the beginning of the next block)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.RTZ">
            <summary>
            Rewinds the tape to it's beginning (return to zero)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.SkipBlock(System.Boolean)">
            <summary>
            Performs a block skip operation on the current tape
            TRUE:   skip forward
            FALSE:  skip backward
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.LoadTape(System.Byte[])">
            <summary>
            Inserts a new tape and sets up the tape device accordingly
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.Reset">
            <summary>
            Resets the tape
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.TapeCycle">
            <summary>
            Is called every cpu cycle but runs every 50 t-states
            This enables the tape devices to play out even if the spectrum itself is not
            requesting tape data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.GetEarBit(System.Int64)">
            <summary>
            Simulates the spectrum 'EAR' input reading data from the tape
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.FlashLoad">
            <summary>
            Flash loading implementation
            (Deterministic Emulation must be FALSE)
            CURRENTLY NOT ENABLED/WORKING
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.MonitorReset">
            <summary>
            Resets the TapeMonitor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.MonitorRead">
            <summary>
            An iteration of the monitor process
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.TAPE_BIT">
            <summary>
            Mask constants
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DatacorderDevice.SyncState(BizHawk.Common.Serializer)">
            <summary>
            Bizhawk state serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN">
            <summary>
            Used for the sector CHRN structure
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.C">
            <summary>
            Track
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.H">
            <summary>
            Side
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.R">
            <summary>
            Sector ID
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.N">
            <summary>
            Sector Size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN._flag1">
            <summary>
            Status register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN._flag2">
            <summary>
            Status register 2
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.DataBytes">
            <summary>
            Used to store the last transmitted/received data bytes
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.DataID">
            <summary>
            ID for the read/write data command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST1MA">
            <summary>
            Missing Address Mark (Sector_ID or DAM not found)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST1ND">
            <summary>
            No Data (Sector_ID not found, CRC fail in ID_field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST1DE">
            <summary>
            Data Error (CRC-fail in ID- or Data-Field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST1EN">
            <summary>
            End of Track (set past most read/write commands) (see IC)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST2MD">
            <summary>
            Missing Address Mark in Data Field (DAM not found)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST2BC">
            <summary>
            Bad Cylinder (read/programmed track-ID different and read-ID = FF)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST2WC">
            <summary>
            Wrong Cylinder (read/programmed track-ID different) (see b1)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST2DD">
            <summary>
            Data Error in Data Field (CRC-fail in data-field)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CHRN.ST2CM">
            <summary>
            Control Mark (read/scan command found sector with deleted DAM)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765">
            <summary>
            The NEC floppy disk controller (and floppy drive) found in the +3
            </summary>
            <summary>
            Definitions
            </summary>
            <summary>
            FDC State and Methods
            </summary>
            <summary>
            Floppy drive related stuff
            </summary>
            <summary>
            IPortIODevice
            </summary>
            <summary>
            Timimng
            </summary>
            <summary>
            Static helper methods
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765._machine">
            <summary>
            The emulated spectrum machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.#ctor">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Init(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase)">
            <summary>
            Initialization routine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Reset">
            <summary>
            Resets the FDC
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InitCommandList">
            <summary>
            Setup the command structure
            Each command represents one of the internal UPD765 commands
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Phase">
            <summary>
            Defines the current phase of the controller
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Phase.Idle">
            <summary>
            FDC is in an idle state, awaiting the next initial command byte
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Phase.Command">
            <summary>
            FDC is in a state waiting for the next command instruction
            A command consists of a command byte (eventually including the MF, MK, SK bits), and up to eight parameter bytes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Phase.Execution">
            <summary>
            During this phase, the actual data is transferred (if any). Usually that are the data bytes for the read/written sector(s), except for the Format Track Command, 
            in that case four bytes for each sector are transferred
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Phase.Result">
            <summary>
            Returns up to seven result bytes (depending on the command) that are containing status information. The Recalibrate and Seek Track commands do not return result bytes directly, 
            instead the program must wait until the Main Status Register signalizes that the command has been completed, and then it must (!) send a 
            Sense Interrupt State command to 'terminate' the Seek/Recalibrate command.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState">
            <summary>
            The lifecycle of an instruction
            Similar to phase, this describes the current 'sub-phase' we are in when dealing with an instruction
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.ReceivingParameters">
            <summary>
            FDC has received a command byte and is currently reading parameter bytes from the data bus
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.PreExecution">
            <summary>
            All parameter bytes have been received. This phase allows any neccessary setup before instruction execution starts
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.StartExecute">
            <summary>
            The start of instruction execution. This may end up with the FDC moving into result phase, 
            but also may also prepare the way for further processing to occur later in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.ExecutionReadWrite">
            <summary>
            Data is read or written in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.ExecutionWrite">
            <summary>
            Execution phase is well under way. This state primarily deals with data transfer between CPU and FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.ExecutionRead">
            <summary>
            Execution phase is well under way. This state primarily deals with data transfer between FDC and CPU
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.StartResult">
            <summary>
            Execution has finished and results bytes are ready to be read by the CPU
            Initial result setup
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.ProcessResult">
            <summary>
            Result processing
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.SendingResults">
            <summary>
            Results are being sent
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InstructionState.Completed">
            <summary>
            Final cleanup tasks when the instruction has fully completed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState">
            <summary>
            Represents internal interrupt state of the FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState.None">
            <summary>
            There is no interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState.Execution">
            <summary>
            Execution interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState.Result">
            <summary>
            Result interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState.Ready">
            <summary>
            Ready interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptState.Seek">
            <summary>
            Seek interrupt
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState">
            <summary>
            Possible main states that each drive can be in
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.None">
            <summary>
            Drive is not doing anything
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.Seek">
            <summary>
            Seek operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.Recalibrate">
            <summary>
            Recalibrate operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.Scan">
            <summary>
            A scan data operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.ReadID">
            <summary>
            A read ID operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.ReadData">
            <summary>
            A read data operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.ReadDiagnostic">
            <summary>
            A read diagnostic (read track) operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.WriteID">
            <summary>
            A write id (format track) operation is in progress
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveMainState.WriteData">
            <summary>
            A write data operation is in progress
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState">
            <summary>
            State information during a seek/recalibration operation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.Idle">
            <summary>
            Seek hasnt started yet
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.Wait">
            <summary>
            Delayed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.MoveInit">
            <summary>
            Setup for head move
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.HeadMove">
            <summary>
            Seek is currently happening
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.MoveImmediate">
            <summary>
            Head move with no delay
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.PerformCompletion">
            <summary>
            Ready to complete
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekSubState.SeekCompleted">
            <summary>
            Seek operation has completed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SeekIntStatus">
            <summary>
            Seek int code
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandDirection">
            <summary>
            The direction of a specific command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandDirection.OUT">
            <summary>
            Data flows from UPD765A to Z80
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandDirection.IN">
            <summary>
            Data flows from Z80 to UPD765A
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResultType">
            <summary>
            Enum defining the different types of result that can be returned
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResultType.Standard">
            <summary>
            Standard 7 result bytes are returned
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResultType.ST3">
            <summary>
            1 byte returned - ST3
            (used for SenseDriveStatus)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResultType.ST0">
            <summary>
            1 byte returned - ST0
            (used for version &amp; invalid)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResultType.Interrupt">
            <summary>
            2 bytes returned for sense interrupt status command
            ST0
            CurrentCylinder
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status">
            <summary>
            Possible list of encountered drive status errors
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.None">
            <summary>
            No error detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.Undefined">
            <summary>
            An undefined error has been detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.DriveNotReady">
            <summary>
            Drive is not ready
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.Invalid">
            <summary>
            Invalid command received
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.WriteProtected">
            <summary>
            The disk has its write protection tab enabled
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status.SectorNotFound">
            <summary>
            The requested sector has not been found
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SkipDirection">
            <summary>
            Represents the direction that the head is moving over the cylinders
            Increment:  Track number increasing (head moving from outside of disk inwards)
            Decrement:  Track number decreasing (head moving from inside of disk outwards)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_C">
            <summary>
            C - Track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_H">
            <summary>
            H - Side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_R">
            <summary>
            R - Sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_N">
            <summary>
            N - Sector size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_EOT">
            <summary>
            EOT - End of track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_GPL">
            <summary>
            GPL - Gap length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_DTL">
            <summary>
            DTL - Data length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CM_STP">
            <summary>
            STP - Step
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_ST0">
            <summary>
            Status register 0
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_ST1">
            <summary>
            Status register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_ST2">
            <summary>
            Status register 2
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_C">
            <summary>
            C - Track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_H">
            <summary>
            H - Side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_R">
            <summary>
            R - Sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.RS_N">
            <summary>
            N - Sector size
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_D0B">
            <summary>
            FDD0 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 0 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_D1B">
            <summary>
            FDD1 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 1 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_D2B">
            <summary>
            FDD2 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 2 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_D3B">
            <summary>
            FDD3 Busy (seek/recalib active, until succesful sense intstat)
            FDD number 3 is in the seek mode. If any of the DnB bits IS set FDC will not accept read or write command.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_CB">
            <summary>
            FDC Busy (still in command-, execution- or result-phase)
            A Read or Write command is in orocess. (FDC Busy) FDC will not accept any other command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_EXM">
            <summary>
            Execution Mode (still in execution-phase, non_DMA_only)
            This bit is set only during execution ohase (Execution Mode) in non-DMA mode When DB5 goes low, execution phase has ended and result phase has started.It operates only during
             non-DMA mode of operation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_DIO">
            <summary>
            Data Input/Output (0=CPU->FDC, 1=FDC->CPU) (see b7)
            Indicates direction of data transfer between FDC and data regrster If DIO = 1, then transfer is from data register to the
            processor.If DIO = 0, then transfer is from the processor to data register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.MSR_RQM">
            <summary>
            Request For Master (1=ready for next byte) (see b6 for direction)
            ndicates data register IS ready to send or receive data to or from the processor Both bits DIO and RQM should be 
            used to perform the hand-shaking functions of “ready” and “directron” to the processor
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_US0">
            <summary>
            Unit Select (driveno during interrupt)
            This flag IS used to indicate a drive unit number at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_US1">
            <summary>
            Unit Select (driveno during interrupt)
            This flag IS used to indicate a drive unit number at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_HD">
            <summary>
            Head Address (head during interrupt)
            State of the head at interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_NR">
            <summary>
            Not Ready (drive not ready or non-existing 2nd head selected)
            Not Ready - When the FDD IS in the not-ready state and a Read or Write command IS Issued, this
             flag IS set If a Read or Write command is issued to side 1 of a single-sided drive, then this flag IS set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_EC">
            <summary>
            Equipment Check (drive failure or recalibrate failed (retry))
            Equipment check - If a fault srgnal IS received from the FDD, or if the track 0 srgnal fails to occur after 77
             step pulses(Recalibrate Command) then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_SE">
            <summary>
            Seek End (Set if seek-command completed)
            Seek end - When the FDC completes the Seek command, this flag IS set lo 1 (high)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_IC0">
            <summary>
            Interrupt Code (low byte)
            Interrupt Code (0=OK, 1=aborted:readfail/OK if EN, 2=unknown cmd
            or senseint with no int occured, 3=aborted:disc removed etc.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR0_IC1">
            <summary>
            Interrupt Code (high byte)
            Interrupt Code (0=OK, 1=aborted:readfail/OK if EN, 2=unknown cmd
            or senseint with no int occured, 3=aborted:disc removed etc.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_MA">
            <summary>
            Missing Address Mark (Sector_ID or DAM not found)
            Missing address mark - This bit is set i f the FDC does not detect the IDAM before 2 index pulses It is also set if
             the FDC cannot find the DAM or DDAM after the IDAM i s found.MD bit of ST2 is also set at this time
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_NW">
            <summary>
            Not Writeable (tried to write/format disc with wprot_tab=on)
            Not writable (write protect) - During execution of Write Data, Write Deleted Data or Write ID command. if the FDC
             detect: a write protect srgnal from the FDD.then this flag is Set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_ND">
            <summary>
            No Data
            No Data (Sector_ID not found, CRC fail in ID_field)
            
            During execution of Read Data. Read Deleted Data Write Data.Write Deleted Data or Scan command, if the FDC cannot find
            the sector specified in the IDR(2)Register, this flag i s set.
            
            During execution of the Read ID command. if the FDC cannot read the ID field without an error, then this flag IS set
            
            During execution of the Read Diagnostic command. if the starting sector cannot be found, then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_OR">
            <summary>
            Over Run (CPU too slow in execution-phase (ca. 26us/Byte))
            Overrun - If the FDC i s not serviced by the host system during data transfers within a certain time interval.this flaa i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_DE">
            <summary>
            Data Error (CRC-fail in ID- or Data-Field)
            Data error - When the FDC detects a CRC(1) error in either the ID field or the data field, this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR1_EN">
            <summary>
            End of Track (set past most read/write commands) (see IC)
            End of cylinder - When the FDC tries to access a sector beyond the final sector of a cylinder, this flag I S set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_MD">
            <summary>
            Missing Address Mark in Data Field (DAM not found)
            Missing address mark - When data IS read from the medium, i f the FDC cannot find a data address mark or deleted 
            data address mark, then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_BC">
            <summary>
            Bad Cylinder (read/programmed track-ID different and read-ID = FF)
            Bad cylinder - This bit i s related to the ND bit. and when the contents of C on the medium is different
            from that stored i n the IDR and the contents  of C IS FFH.then this flag IS set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_SN">
            <summary>
            Scan Not Satisfied (no fitting sector found)
            Scan not satisfied - During execution of the Scan command, i f the F D cannot find a sector on the cylinder 
            which meets the condition.then this flag i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_SH">
            <summary>
            Scan Equal Hit (equal)
            Scan equal hit - During execution of the Scan command. i f the condition of “equal” is satisfied, this flag i s set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_WC">
            <summary>
            Wrong Cylinder (read/programmed track-ID different) (see b1)
            Wrong cylinder - This bit IS related to the ND bit, and when  the contents of C(3) on the medium is different 
            from that stored i n the IDR.this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_DD">
            <summary>
            Data Error in Data Field (CRC-fail in data-field)
            Data error in data field - If the FDC detects a CRC error i n the data field then this flag is set
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR2_CM">
            <summary>
            Control Mark (read/scan command found sector with deleted DAM)
            Control mark - During execution of the Read Data or Scan command, if the FDC encounters a sector
             which contains a deleted data address mark, this flag is set Also set if DAM is
              found during Read Deleted Data
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_US0">
            <summary>
            Unit select 0
            Unit Select (pin 28,29 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_US1">
            <summary>
            Unit select 1
            Unit Select (pin 28,29 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_HD">
            <summary>
            Head address (side select)
            Head Address (pin 27 of FDC)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_TS">
            <summary>
            Two Side (0=yes, 1=no (!))
            Two-side - This bit IS used to indicate the status of the two-side signal from the FDD
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_T0">
            <summary>
            Track 0 (on track 0 we are)
            Track 0 - This bit IS used to indicate the status of the track 0 signal from the FDD
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_RY">
            <summary>
            Ready - status of the ready signal from the fdd
            Ready (drive ready signal)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_WP">
            <summary>
            Write Protected (write protected)
            Write protect - status of the wp signal from the fdd
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SR3_FT">
            <summary>
            Fault - This bit is used to indicate the status of the fault signal from the FDD
            Fault (if supported: 1=Drive failure)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.IC_OK">
            <summary>
            1 = aborted:readfail / OK if EN (end of track)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.IC_ABORTED_RF_OKEN">
            <summary>
            1 = aborted:readfail / OK if EN (end of track)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.IC_NO_INT_OCCURED">
            <summary>
            2 = unknown cmd or senseint with no int occured
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.IC_ABORTED_DISCREMOVED">
            <summary>
            3 = aborted:disc removed etc
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command">
            <summary>
            Class that holds information about a specific command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.CommandCode">
            <summary>
            The command code after bitmask has been applied
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.ParameterByteCount">
            <summary>
            The number of bytes that make up the full command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.ResultByteCount">
            <summary>
            The number of result bytes that will be generated from the command
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.Direction">
            <summary>
            The command direction
            IN - Z80 to UPD765A
            OUT - UPD765A to Z80
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.MT">
            <summary>
            Command makes use of the MT bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.MF">
            <summary>
            Command makes use of the MF bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.SK">
            <summary>
            Command makes use of the SK bit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.IsRead">
            <summary>
            Read/Write command that is READ
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.IsWrite">
            <summary>
            Read/Write command that is WRITE
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Command.CommandDelegate">
            <summary>
            Delegate function that is called by this command
            bool 1: EXECUTE - if TRUE the command will be executed. if FALSE the method will instead parse commmand parameter bytes
            bool 2: RESULT - if TRUE
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters">
            <summary>
            Storage for command parameters
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.UnitSelect">
            <summary>
            The requested drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Side">
            <summary>
            The requested physical side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Cylinder">
            <summary>
            The requested track (C)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Head">
            <summary>
            The requested head (H)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Sector">
            <summary>
            The requested sector (R)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.SectorSize">
            <summary>
            The specified sector size (N)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.EOT">
            <summary>
            The end of track or last sector value (EOT)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Gap3Length">
            <summary>
            Gap3 length (GPL)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.DTL">
            <summary>
            Data length (DTL) - When N is defined as 00, DTL stands for the data length 
            which users are going to read out or write into the sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandParameters.Reset">
            <summary>
            Clear down
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveLight">
            <summary>
            Signs whether the drive is active
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommandList">
            <summary>
            Collection of possible commands
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ActiveCommandParams">
            <summary>
            State parameters relating to the Active command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ActivePhase">
            <summary>
            The current active phase of the controller
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ActiveInterrupt">
            <summary>
            The currently active interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommBuffer">
            <summary>
            Command buffer
            This does not contain the initial command byte (only parameter bytes)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommCounter">
            <summary>
            Current index within the command buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CMD_FLAG_MT">
            <summary>
            Initial command byte flag
            Bit7  Multi Track (continue multi-sector-function on other head)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CMD_FLAG_MF">
            <summary>
            Initial command byte flag
            Bit6  MFM-Mode-Bit (Default 1=Double Density)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CMD_FLAG_SK">
            <summary>
            Initial command byte flag
            Bit5  Skip-Bit (set if secs with deleted DAM shall be skipped)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SRT">
            <summary>
            Step Rate Time (supplied via the specify command)
            SRT stands for the steooino rate for the FDD ( 1 to 16 ms in 1 ms increments). 
            Stepping rate applies to all drives(FH= 1ms, EH= 2ms, etc.).
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SRT_Counter">
            <summary>
            Keeps track of the current SRT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.HUT">
            <summary>
            Head Unload Time (supplied via the specify command)
            HUT stands for the head unload time after a Read or Write operation has occurred 
            (16 to 240 ms in 16 ms Increments)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.HUT_Counter">
            <summary>
            Keeps track of the current HUT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.HLT">
            <summary>
            Head load Time (supplied via the specify command)
            HLT stands for the head load time in the FDD (2 to 254 ms in 2 ms Increments)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.HLT_Counter">
            <summary>
            Keeps track of the current HLT state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ND">
            <summary>
            Non-DMA Mode (supplied via the specify command)
            ND stands for operation in the non-DMA mode
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.OverrunCounter">
            <summary>
            In lieu of actual timing, this will count status reads in execution phase
            where the CPU hasnt actually read any bytes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResBuffer">
            <summary>
            Contains result bytes in result phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ExecBuffer">
            <summary>
            Contains sector data to be written/read in execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.InterruptResultBuffer">
            <summary>
            Interrupt result buffer
            Persists (and returns when needed) the last result data when a sense interrupt status command happens
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResCounter">
            <summary>
            Current index within the result buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ResLength">
            <summary>
            The byte length of the currently active command
            This may or may not be the same as the actual command resultbytes value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ExecCounter">
            <summary>
            Index for sector data within the result buffer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ExecLength">
            <summary>
            The length of the current exec command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.LastSectorDataWriteByte">
            <summary>
            The last write byte that was received during execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.LastSectorDataReadByte">
            <summary>
            The last read byte to be sent during execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.LastByteReceived">
            <summary>
            The last parameter byte that was written to the FDC
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SectorDelayCounter">
            <summary>
            Delay for reading sector
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SectorID">
            <summary>
            The phyical sector ID
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.IndexPulseCounter">
            <summary>
            Counter for index pulses
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CMDIndex">
            <summary>
            Specifies the index of the currently selected command (in the CommandList)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ActiveCommand">
            <summary>
            The currently active command
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.StatusMain">
            <summary>
            Main status register (accessed via reads to port 0x2ffd)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status0">
            <summary>
            Status Register 0
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status1">
            <summary>
            Status Register 1
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status2">
            <summary>
            Status Register 2
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.Status3">
            <summary>
            Status Register 3
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ReadData">
            <summary>
            Read Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ReadDeletedData">
            <summary>
            Read Deleted Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ReadDiagnostic">
            <summary>
            Read Diagnostic (read track)
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDD and FDC. FDC reads all data fields from index hole to EDT
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ReadID">
            <summary>
            Read ID
            COMMAND:    1 parameter byte
            EXECUTION:  The first correct ID information on the cylinder is stored in the data register
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_WriteData">
            <summary>
            Write Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDC and FDD
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_WriteID">
            <summary>
            Write ID (format write)
            COMMAND:    5 parameter bytes
            EXECUTION:  Entire track is formatted
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_WriteDeletedData">
            <summary>
            Write Deleted Data
            COMMAND:    8 parameter bytes
            EXECUTION:  Data transfer between FDC and FDD
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ScanEqual">
            <summary>
            Scan Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ScanLowOrEqual">
            <summary>
            Scan Low or Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_ScanHighOrEqual">
            <summary>
            Scan High or Equal
            COMMAND:    8 parameter bytes
            EXECUTION:  Data compared between the FDD and FDC
            RESULT:     7 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_Specify">
            <summary>
            Specify
            COMMAND:    2 parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     NO result phase
            
            Looks like specify command returns status 0x80 throughout its lifecycle
            so CB is NOT set
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_Seek">
            <summary>
            Seek
            COMMAND:    2 parameter bytes
            EXECUTION:  Head is positioned over proper cylinder on disk
            RESULT:     NO result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_Recalibrate">
            <summary>
            Recalibrate (seek track 0)
            COMMAND:    1 parameter byte
            EXECUTION:  Head retracted to track 0
            RESULT:     NO result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_SenseInterruptStatus">
            <summary>
            Sense Interrupt Status
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     2 result bytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_SenseDriveStatus">
            <summary>
            Sense Drive Status
            COMMAND:    1 parameter byte
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            
            The ZX spectrum appears to only specify drive 1 as the parameter byte, NOT drive 0
            After the final param byte is received main status changes to 0xd0
            Data register (ST3) result is 0x51 if drive/disk not available
            0x71 if disk is present in 2nd drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_Version">
            <summary>
            Version
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UPD_Invalid">
            <summary>
            Invalid
            COMMAND:    NO parameter bytes
            EXECUTION:  NO execution phase
            RESULT:     1 result byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ReadMainStatus">
            <summary>
            Called when a status register read is required
            This can be called at any time
            The main status register appears to be queried nearly all the time
            so needs to be kept updated. It keeps the CPU informed of the current state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ReadDataRegister">
            <summary>
            Handles CPU reading from the data register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.WriteDataRegister(System.Byte)">
            <summary>
            Handles CPU writing to the data register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ParseCommandByte(System.Byte)">
            <summary>
            Processes the first command byte (within a command instruction)
            Returns TRUE if successful. FALSE if otherwise
            Called only in idle phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ParseParamByteStandard(System.Int32)">
            <summary>
            Parses the first 5 command argument bytes that are of the standard format
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ClearResultBuffer">
            <summary>
            Clears the result buffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ClearExecBuffer">
            <summary>
            Clears the result buffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommitResultStatus">
            <summary>
            Populates the result status registers
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CommitResultCHRN">
            <summary>
            Populates the result CHRN values
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetPhase_Idle">
            <summary>
            Moves active phase into idle
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetPhase_Result">
            <summary>
            Moves to result phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetPhase_Command">
            <summary>
            Moves to command phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetPhase_Execution">
            <summary>
            Moves to execution phase
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.FDD_FLAG_MOTOR">
            <summary>
            FDD Flag - motor on/off
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DiskDriveIndex">
            <summary>
            The index of the currently active disk drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ActiveDrive">
            <summary>
            The currently active drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveStates">
            <summary>
            Array that holds state information for each possible drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.FDD_Init">
            <summary>
            Initialization / reset of the floppy drive subsystem
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.GetSector">
            <summary>
            Searches for the requested sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DiskPointer">
            <summary>
            Returns the disk object from drive 0
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState">
            <summary>
            Holds specfic state information about a drive
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.ID">
            <summary>
            The drive ID from an FDC perspective
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FLAG_READY">
            <summary>
            Signs whether this drive ready
            TRUE if both drive exists and has a disk inserted
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FLAG_WRITEPROTECT">
            <summary>
            Disk is write protected (TRUE BY DEFAULT)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.SeekCounter">
            <summary>
            Storage for seek steps
            One step for each indexpulse (track index) until seeked track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.SeekStatus">
            <summary>
            Seek status
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.SeekAge">
            <summary>
            Age counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.CurrentSide">
            <summary>
            The current side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.TrackIndex">
            <summary>
            The current track index in the DiskTracks array
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.CurrentTrackID">
            <summary>
            The track ID of the current cylinder
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.SeekingTrack">
            <summary>
            The new track that the drive is seeking to
            (used in seek operations)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.SectorIndex">
            <summary>
            The current sector index in the Sectors array
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.Disk">
            <summary>
            The currently loaded floppy disk
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FDC">
            <summary>
            The parent controller
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FLAG_TRACK0">
            <summary>
            TRUE if we are on track 0
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FDD_LoadDisk(System.Byte[])">
            <summary>
            Parses a new disk image and loads it into this floppy drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FDD_EjectDisk">
            <summary>
            Ejects the current disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveState.FDD_IsDiskLoaded">
            <summary>
            Signs whether the current active drive has a disk inserted
            </summary>        
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CurrentCPUCycle">
            <summary>
            The current Z80 cycle
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.LastCPUCycle">
            <summary>
            The last CPU cycle when the FDC accepted an IO read/write
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.StatusDelay">
            <summary>
            The current delay figure (in Z80 t-states)
            This implementation only introduces delay upon main status register reads
            All timing calculations should be done during the other read/write operations
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CPUCyclesPerMs">
            <summary>
            Defines the numbers of Z80 cycles per MS
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveClock">
            <summary>
            The floppy drive emulated clock speed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveCyclesPerMs">
            <summary>
            The number of floppy drive cycles per MS
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.StatesPerDriveTick">
            <summary>
            The number of T-States in one floppy drive clock tick
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.TickCounter">
            <summary>
            Responsible for measuring when the floppy drive is ready to run a cycle
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.DriveCycleCounter">
            <summary>
            Internal drive cycle counter
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.TimingInit">
            <summary>
            Initializes the timing routines
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.CheckTiming">
            <summary>
            Called by reads to the main status register
            Returns true if there is no delay
            Returns false if read is to be deferred
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.GetBit(System.Int32,System.Byte)">
            <summary>
            Returns the specified bit value from supplied byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetBit(System.Int32,System.Byte@)">
            <summary>
            Sets the specified bit of the supplied byte to 1
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.UnSetBit(System.Int32,System.Byte@)">
            <summary>
            Sets the specified bit of the supplied byte to 0
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.GetUnitSelect(System.Byte)">
            <summary>
            Returns a drive number (0-3) based on the first two bits of the supplied byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NECUPD765.SetUnitSelect(System.Int32,System.Byte@)">
            <summary>
            Sets the first two bits of a byte based on the supplied drive number (0-3)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CursorJoystick">
            <summary>
            Cursor joystick
            Maps to a combination of 0xf7fe and 0xeffe
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CursorJoystick.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CursorJoystick.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CursorJoystick.GetBitPos(System.String)">
            <summary>
            Gets the bit position of a particular joystick binding from the matrix
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.KempstonJoystick.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.KempstonJoystick.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.KempstonJoystick.JoyLine">
            <summary>
            Active bits high
            0 0 0 F U D L R
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.KempstonJoystick.GetBitPos(System.String)">
            <summary>
            Gets the bit position of a particular joystick binding from the matrix
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NullJoystick">
            <summary>
            A null joystick object
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NullJoystick.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NullJoystick.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NullJoystick.JoyLine">
            <summary>
            Active bits high
            0 0 0 F U D L R
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.NullJoystick.GetBitPos(System.String)">
            <summary>
            Gets the bit position of a particular joystick binding from the matrix
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick1">
            <summary>
            Sinclair Joystick LEFT
            Just maps to the standard keyboard and is read the same (from port 0xf7fe)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick1.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick1.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick1.GetBitPos(System.String)">
            <summary>
            Gets the bit position of a particular joystick binding from the matrix
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick2">
            <summary>
            Sinclair Joystick RIGHT
            Just maps to the standard keyboard and is read the same (from port 0xeffe)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick2.SetJoyInput(System.String,System.Boolean)">
            <summary>
            Sets the joystick line based on key pressed
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick2.GetJoyInput(System.String)">
            <summary>
            Gets the state of a particular joystick binding
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SinclairJoystick2.GetBitPos(System.String)">
            <summary>
            Gets the bit position of a particular joystick binding from the matrix
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.StandardKeyboard">
            <summary>
            The 48k keyboard device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.StandardKeyboard.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            Device responds to an IN instruction
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.StandardKeyboard.WritePort(System.UInt16,System.Int32)">
            <summary>
            Device responds to an OUT instruction
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData">
            <summary>
            Information about spectrum ROM
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData.RomBytes">
            <summary>
            ROM Contents
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData.SaveBytesRoutineAddress">
            <summary>
            Useful ROM addresses that are needed during tape operations
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912">
            <summary>
            AY-3-8912 Emulated Device
            
            Based heavily on the YM-2149F / AY-3-8910 emulator used in Unreal Speccy
            (Originally created under Public Domain license by SMT jan.2006)
            
            https://github.com/mkoloberdin/unrealspeccy/blob/master/sndrender/sndchip.cpp
            https://github.com/mkoloberdin/unrealspeccy/blob/master/sndrender/sndchip.h
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._machine">
            <summary>
            The emulated machine (passed in via constructor)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase)">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.Init(System.Int32,System.Int32)">
            <summary>
            Initialises the AY chip
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.ReadPort(System.UInt16,System.Int32@)">
            <summary>
            |11-- ---- ---- --0-|	-	IN	-	Read value of currently selected register	
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.WritePort(System.UInt16,System.Int32)">
            <summary>
            |11-- ---- ---- --0-|	-	OUT	-	Register Select
            |10-- ---- ---- --0-|	-	OUT	-	Write value to currently selected register
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.AYPanConfig">
            <summary>
            AY mixer panning configuration
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.PanningConfiguration">
            <summary>
            The AY panning configuration
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.Volume">
            <summary>
            The AY chip output volume
            (0 - 100)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.SelectedRegister">
            <summary>
            The currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.ExportRegisters">
            <summary>
            Used for snapshot generation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.Reset">
            <summary>
            Resets the PSG
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.PortRead">
            <summary>
            Reads the value from the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.PortWrite(System.Int32)">
            <summary>
            Writes to the currently selected register
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.StartFrame">
            <summary>
            Start of frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.EndFrame">
            <summary>
            End of frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.UpdateSound(System.Int32)">
            <summary>
            Updates the audiobuffer based on the current frame t-state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.AY_A_FINE">
            <summary>
            Register indicies
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._registers">
            <summary>
            The register array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._activeRegister">
            <summary>
            The currently selected register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._chipFrequency">
            <summary>
            The frequency of the AY chip
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._resolution">
            <summary>
            The rendering resolution of the chip
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._bitA">
            <summary>
            Channel generator state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._eState">
            <summary>
            Envelope state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._eDirection">
            <summary>
            Envelope direction
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._noiseSeed">
            <summary>
            Noise seed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._bit0">
            <summary>
            Mixer state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._bitN">
            <summary>
            Noise generator state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._eMaskA">
            <summary>
            Envelope masks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._vA">
            <summary>
            Amplitudes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._countA">
            <summary>
            Channel gen counters
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._countE">
            <summary>
            Envelope gen counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._countN">
            <summary>
            Noise gen counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._dividerA">
            <summary>
            Channel gen dividers
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._dividerE">
            <summary>
             Envelope gen divider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._dividerN">
            <summary>
            Noise gen divider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.PanTabs">
            <summary>
            Panning table list
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._currentPanTab">
            <summary>
            The currently selected panning configuration
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._volume">
            <summary>
            The current volume
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912._volumeTables">
            <summary>
            Volume tables state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.AYVolumes">
            <summary>
            Volume table to be used
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.UpdateVolume">
            <summary>
            Forces an update of the volume tables
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.InitTiming(System.Int32,System.Int32)">
            <summary>
            Initializes timing information for the frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.BufferUpdate(System.Int32)">
            <summary>
            Updates the audiobuffer based on the current frame t-state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.AY38912.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor">
            <summary>
            An intermediary class that manages cycling the ULA and CPU
            along with inherent Port and Memory contention
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.TotalExecutedCycles">
            <summary>
            CPU total executes t-states
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.BUSRQ">
            <summary>
            Current BUSRQ line array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.lastPortAddr">
            <summary>
            The last 16-bit port address that was detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.NextMemReadContended">
            <summary>
            If true, the next read memory operation has been contended
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.ExecuteCycle">
            <summary>
            Handles the ULA and CPU cycle clocks, along with any memory and port contention
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.AscertainBUSRQAddress">
            <summary>
            Looks up the current BUSRQ address that is about to be signalled on the upcoming cycle
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.CheckIO">
            <summary>
            Running every cycle, this determines whether the upcoming BUSRQ is for an IO operation
            Also processes any contention
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.IsIOCycleContended(System.Int32)">
            <summary>
            Returns TRUE if the supplied T-cycle within an IO operation has the possibility of being contended
            This can be different based on the emulated ZX Spectrum model
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPUMonitor.OnExecFetch(System.UInt16)">
            <summary>
            Called when the first byte of an instruction is fetched
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType">
            <summary>
            The various spectrum models ZXHawk emulates
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum16">
            <summary>
            Original Sinclair Spectrum 16K model
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum48">
            <summary>
            Sinclair Spectrum 48K model
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum128">
            <summary>
            Sinclair Spectrum 128K model
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum128Plus2">
            <summary>
            Sinclair Spectrum 128 +2 model
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum128Plus2a">
            <summary>
            Sinclair Spectrum 128 +2a model (same as the +3 just without disk drive)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.ZXSpectrum128Plus3">
            <summary>
            Sinclair Spectrum 128 +3 model
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType.Pentagon128">
            <summary>
            Russian 128k pentagon clone
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128">
            <summary>
            128K Constructor
            </summary>
            <summary>
            Pentagon 128k Memory
            </summary>
            <summary>
            Pentagon 128K Port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.FetchScreenMemory(System.UInt16)">
            <summary>
            ULA reads the memory at the specified address
            (No memory contention)
            Will read RAM5 (screen0) by default, unless RAM7 (screen1) is selected as output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Pentagon128.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ScreenPentagon128">
            <summary>
            128K/+2 ULA
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase">
            <summary>
            The abstract class that all emulated models will inherit from
            * Main properties / fields / contruction*
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Input *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Imported media *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Memory *
            </summary>
            <summary>
            The abstract class that all emulated models will inherit from
            * Port Access *
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.Spectrum">
            <summary>
            The calling ZXSpectrum class (piped in via constructor)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.CPU">
            <summary>
            Reference to the instantiated Z80 cpu (piped in via constructor)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.RomData">
            <summary>
            ROM and extended info
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ULADevice">
            <summary>
            The emulated ULA device
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.CPUMon">
            <summary>
            Monitors CPU cycles
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.BuzzerDevice">
            <summary>
            The spectrum buzzer/beeper
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.TapeBuzzer">
            <summary>
            A second beeper for the tape
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.AYDevice">
            <summary>
            Device representing the AY-3-8912 chip found in the 128k and up spectrums
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.KeyboardDevice">
            <summary>
            The spectrum keyboard
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.TapeDevice">
            <summary>
            The spectrum datacorder device
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.UPDDiskDevice">
            <summary>
            The +3 built-in disk drive
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.JoystickCollection">
            <summary>
            Holds the currently selected joysticks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.PrinterPortStrobe">
            <summary>
            +3/2a printer port strobe
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.FrameCompleted">
            <summary>
            Signs whether the frame has ended
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.OverFlow">
            <summary>
            Overflow from the previous frame (in Z80 cycles)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.FrameCount">
            <summary>
            The total number of frames rendered
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase._frameCycles">
            <summary>
            The current cycle (T-State) that we are at in the frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LastFrameStartCPUTick">
            <summary>
            Stores where we are in the frame after each CPU cycle
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.CurrentFrameCycle">
            <summary>
            Gets the current frame cycle according to the CPU tick count
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase._render">
            <summary>
            Non-Deterministic bools
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.BORDER_BIT">
            <summary>
            Mask constants &amp; misc
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ExecuteFrame(System.Boolean,System.Boolean)">
            <summary>
            Executes a single frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.HardReset">
            <summary>
            Hard reset of the emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.SoftReset">
            <summary>
            Soft reset of the emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.PollInput">
            <summary>
            Cycles through all the input callbacks
            This should be done once per frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.InitJoysticks(System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Instantiates the joysticks array
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.InstantiateJoystick(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType,System.Int32)">
            <summary>
            Instantiates a new IJoystick object
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LocateUniqueJoystick(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType)">
            <summary>
            Returns a IJoystick object depending on the type (or null if not found)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.inputRead">
            <summary>
            Signs whether input read has been requested
            This forms part of the IEmulator LagFrame implementation
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.mediaImages">
            <summary>
            The tape or disk image(s) that are passed in from the main ZXSpectrum class
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.tapeImages">
            <summary>
            Tape images
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.diskImages">
            <summary>
            Disk images
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.IsLoadState">
            <summary>
            Set when a savestate is loaded
            (Used to cancel any tape/disk load messages after a loadstate)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.tapeMediaIndex">
            <summary>
            The index of the currently 'loaded' tape image
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.diskMediaIndex">
            <summary>
            The index of the currently 'loaded' disk image
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.InitializeMedia(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Called on first instantiation (and subsequent core reboots)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LoadAllMedia">
            <summary>
            Attempts to load all media into the relevant structures
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LoadTapeMedia">
            <summary>
            Attempts to load a tape into the tape device based on tapeMediaIndex
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LoadDiskMedia">
            <summary>
            Attempts to load a disk into the disk device based on diskMediaIndex
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.IdentifyMedia(System.Byte[])">
            <summary>
            Identifies and sorts the various media types
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ROM0">
            <summary>
            ROM Banks
            </summary>        
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.RAM0">
            <summary>
            RAM Banks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.SHADOWPaged">
            <summary>
            Signs that the shadow screen is now displaying
            Note: normal screen memory in RAM5 is not altered, the ULA just outputs Screen1 instead (RAM7)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.RAMPaged">
            <summary>
            Index of the current RAM page
            /// 128k, +2/2a and +3 only
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.PagingDisabled">
            <summary>
            Signs that all paging is disabled
            If this is TRUE, then 128k and above machines need a hard reset before paging is allowed again
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ROMPaged">
            <summary>
            Index of the currently paged ROM
            128k, +2/2a and +3 only
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ROMhigh">
            <summary>
            High bit of the ROM selection (in normal paging mode)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ROMlow">
            <summary>
            Low bit of the ROM selection (in normal paging mode)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.SpecialPagingMode">
            <summary>
            Signs that the +2a/+3 special paging mode is activated
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.PagingConfiguration">
            <summary>
            Index of the current special paging mode (0-3)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LastContendedReadByte">
            <summary>
            The last byte that was read after contended cycles
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.PushBus">
            <summary>
             Pushes a value onto the data bus that should be valid as long as the interrupt is true
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.FetchScreenMemory(System.UInt16)">
            <summary>
            ULA reads the memory at the specified address
            (No memory contention)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.IsIn48kMode">
            <summary>
            Detects whether this is a 48k machine (or a 128k in 48k mode)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.TestForTapeTraps(System.Int32)">
            <summary>
            Monitors ROM access
            Used to auto start/stop the tape device when appropriate
            * This isnt really used anymore for tape trap detection *
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.LastULAOutByte">
            <summary>
            The last OUT data that was sent to the ULA
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA">
            <summary>
            Uncommitted logic array implementation (ULA)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA._machine">
            <summary>
            The emulated spectrum
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.CPUMon">
            <summary>
            The CPU monitor class
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ULAPalette">
            <summary>
            The standard ULA palette
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ClockSpeed">
            <summary>
            The CPU speed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.FrameCycleLength">
            <summary>
            Length of frame in T-State cycles
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.InterruptStartTime">
            <summary>
            The T-State at which the interrupt should be raised within the frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.InterruptLength">
            <summary>
            The period for which the interrupt should he held
            (simulated /INT pin held low)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ContentionOffset">
            <summary>
            Contention offset
            </summary> 
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTableOffset">
            <summary>
            Arbitrary offset for render table generation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.FloatingBusOffset">
            <summary>
            The offset when return floating bus bytes
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ScanlineTime">
            <summary>
            The time in T-States for one scanline to complete
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderLeftTime">
            <summary>
            T-States at the left border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderRightTime">
            <summary>
            T-States at the right border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.InterruptRaised">
            <summary>
            Signs that an interrupt has been raised in this frame.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.CycleClock(System.Int64)">
            <summary>
            Cycles the ULA clock
            Handles interrupt generation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.CalcFlashCounter">
            <summary>
            Flash processing
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ScreenWidth">
            <summary>
            Total pixels in one display row
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ScreenHeight">
            <summary>
            Total pixels in one display column
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderTopHeight">
            <summary>
            Total pixels in top border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderBottomHeight">
            <summary>
            Total pixels in bottom border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderLeftWidth">
            <summary>
            Total pixels in left border width
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.BorderRightWidth">
            <summary>
            Total pixels in right border width
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ScanLineWidth">
            <summary>
            Total pixels in one scanline
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.LastTState">
            <summary>
            The last T-State cycle at which the screen was rendered
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.flashOn">
            <summary>
            Flash state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderingTable">
            <summary>
            Holds all information regarding rendering the screen based on the current T-State
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable">
            <summary>
            Holds all information regarding rendering the screen based on the current T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable._ula">
            <summary>
            The ULA device
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.Renderer">
            <summary>
            Array of rendercycle entries
            Starting from the interrupt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable._machineType">
            <summary>
            The emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA,BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.InitRenderer(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType)">
            <summary>
            Initializes the renderer
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle">
            <summary>
            Render/contention information for a single T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.RAction">
            <summary>
            The ULA render action at this T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.ContentionValue">
            <summary>
            The contention value at this T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.ByteAddress">
            <summary>
            The screen byte address at this T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.AttributeAddress">
            <summary>
            The screen attribute address at this T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.FloatingBusAddress">
            <summary>
            The byte address returned by the floating bus at this T-State
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderTable.RenderCycle.LineOffset">
            <summary>
            The offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.RenderScreen(System.Int32)">
            <summary>
            Renders to the screen buffer based on the current cycle
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.GenerateP3PortTable">
            <summary>
            Generates the port lookup table for +2a/+3 allowed floating bus ports
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ReadFloatingBus(System.Int32,System.Int32@,System.UInt16)">
            <summary>
            Returns floating bus value (if available)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.GetContentionValue">
            <summary>
            Returns the contention value for the current t-state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.GetContentionValue(System.Int32)">
            <summary>
            Returns the contention value for the supplied t-state
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.GetPortContentionValue(System.Int32)">
            <summary>
            Returns the contention value for the supplied t-state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ULA.ScreenBuffer">
            <summary>
            Video output buffer
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a">
            <summary>
            +2A Constructor
            </summary>
            <summary>
            +2A Memory
            </summary>
            <summary>
            +2a Port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.FetchScreenMemory(System.UInt16)">
            <summary>
            ULA reads the memory at the specified address
            (No memory contention)
            Will read RAM5 (screen0) by default, unless RAM7 (screen1) is selected as output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2a._ROMpaged">
            <summary>
            +3 and 2a overidden method
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Screen128Plus2a">
            <summary>
            +2A/+3 ULA
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2">
            <summary>
            The +2 is almost identical to the 128k from an emulation point of view
            There are just a few small changes in the ROMs
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus2.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3">
            <summary>
            +3 Constructor
            </summary>
            <summary>
            +3 Memory
            </summary>
            <summary>
            +3 Port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.FetchScreenMemory(System.UInt16)">
            <summary>
            ULA reads the memory at the specified address
            (No memory contention)
            Will read RAM5 (screen0) by default, unless RAM7 (screen1) is selected as output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128Plus3._ROMpaged">
            <summary>
            +3 and 2a overidden method
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128">
            <summary>
            128K Constructor
            </summary>
            <summary>
            128K and +2 Memory
            </summary>
            <summary>
            128K/+2 Port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.FetchScreenMemory(System.UInt16)">
            <summary>
            ULA reads the memory at the specified address
            (No memory contention)
            Will read RAM5 (screen0) by default, unless RAM7 (screen1) is selected as output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX128.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Screen128">
            <summary>
            128K/+2 ULA
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16">
            <summary>
            16K is idential to 48K, just without the top 32KB of RAM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX16.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48">
            <summary>
            48K construction
            </summary>
            <summary>
            48K Memory
            </summary>
            <summary>
            48K Port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.#ctor(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum,BizHawk.Emulation.Cores.Components.Z80A.Z80A{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CpuLink},BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType,System.Collections.Generic.List{System.Byte[]},System.Collections.Generic.List{BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType})">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.ReadBus(System.UInt16)">
            <summary>
            Simulates reading from the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing to the bus (no contention)
            Paging should be handled here
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.ReadMemory(System.UInt16)">
            <summary>
            Reads a byte of data from a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.ReadCDL(System.UInt16)">
            <summary>
            Returns the ROM/RAM enum that relates to this particular memory read operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.WriteMemory(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified memory address
            (with memory contention if appropriate)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.IsContended(System.UInt16)">
            <summary>
            Checks whether supplied address is in a potentially contended bank
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.ContendedBankPaged">
            <summary>
            Returns TRUE if there is a contended bank paged in
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.InitROM(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.RomData)">
            <summary>
            Sets up the ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.ReadPort(System.UInt16)">
            <summary>
            Reads a byte of data from a specified port address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZX48.WritePort(System.UInt16,System.Byte)">
            <summary>
            Writes a byte of data to a specified port address
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.Screen48">
            <summary>
            48K ULA
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCExtendedFloppyDisk">
            <summary>
            Logical object representing a standard +3 disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCExtendedFloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCExtendedFloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCExtendedFloppyDisk.SplitDoubleSided(System.Byte[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Takes a double-sided disk byte array and converts into 2 single-sided arrays
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCExtendedFloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCFloppyDisk">
            <summary>
            Logical object representing a standard +3 disk image
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCFloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCFloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data 
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCFloppyDisk.SplitDoubleSided(System.Byte[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Takes a double-sided disk byte array and converts into 2 single-sided arrays
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CPCFloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType">
            <summary>
            The different disk formats ZXHawk currently supports
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType.CPC">
            <summary>
            Standard CPCEMU disk format (used in the built-in +3 disk drive)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType.CPCExtended">
            <summary>
            Extended CPCEMU disk format (used in the built-in +3 disk drive)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType.IPF">
            <summary>
            Interchangeable Preservation Format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType.UDI">
            <summary>
            Ultra Disk Image Format (v1.0)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.DiskType.UDIv1_1">
            <summary>
            Ultra Disk Image Format (v1.1)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk">
            <summary>
            This abstract class defines a logical floppy disk
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DiskFormatType">
            <summary>
            The disk format type
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DiskHeader">
            <summary>
            Disk information header
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DiskTracks">
            <summary>
            Track array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.CylinderCount">
            <summary>
            No. of tracks per side
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.SideCount">
            <summary>
            The number of physical sides
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.BytesPerTrack">
            <summary>
            The number of bytes per track
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.WriteProtected">
            <summary>
            The write-protect tab on the disk
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.Protection">
            <summary>
            The detected protection scheme (if any)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DiskData">
            <summary>
            The actual disk image data
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DirtyData">
            <summary>
            If TRUE then data on the disk has changed (been written to)
            This will be used to determine whether the disk data needs to be included
            in any SyncState operations
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.RandomCounter">
            <summary>
            Used to deterministically choose a 'random' sector when dealing with weak reads
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.ParseProtection">
            <summary>
            Examines the floppydisk data to work out what protection (if any) is present
            If possible it will also fix the disk data for this protection
            This should be run at the end of the ParseDisk() method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DetectShadowOfTheBeast">
            <summary>
            Detection routine for shadow of the beast game
            Still cannot get this to work, but at least the game is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DetectSpeedlock(System.Int32[]@)">
            <summary>
            Detect speedlock weak sector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DetectAlkatraz(System.Int32[]@)">
            <summary>
            Detect Alkatraz
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DetectPaulOwens(System.Int32[]@)">
            <summary>
            Detect Paul Owens
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.DetectHexagon(System.Int32[]@)">
            <summary>
            Detect Hexagon copy protection
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.GetTrackCount">
            <summary>
            Returns the track count for the disk
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.ReadID(System.Byte,System.Byte,System.Int32)">
            <summary>
            Reads the current sector ID info
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serialization routines
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.FloppyDisk.Track.TrackSectorData">
            <summary>
            Presents a contiguous byte array of all sector data for this track
            (including any multiple weak/random data)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ProtectionType">
            <summary>
            Defines the type of speedlock detection found
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPFFloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPFFloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data 
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.IPFFloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.UDI1_0FloppyDisk.DiskFormatType">
            <summary>
            The format type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.UDI1_0FloppyDisk.ParseDisk(System.Byte[])">
            <summary>
            Attempts to parse incoming disk data 
            </summary>
            <returns>
            TRUE:   disk parsed
            FALSE:  unable to parse disk
            </returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.UDI1_0FloppyDisk.SplitDoubleSided(System.Byte[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Takes a double-sided disk byte array and converts into 2 single-sided arrays
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.UDI1_0FloppyDisk.UDIv1Track.Sectors">
            <summary>
            Parse the UDI TrackData byte[] array into sector objects
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.UDI1_0FloppyDisk.SyncState(BizHawk.Common.Serializer)">
            <summary>
            State serlialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter">
            <summary>
            Abtract class that represents all Media Converters
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.FormatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.Read(System.Byte[])">
            <summary>
            Serialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.Write(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.CheckType(System.Byte[])">
            <summary>
            Serializer does a quick check, returns TRUE if file is detected as this type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetBytes(System.Int32)">
            <summary>
            Converts an int32 value into a byte array
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetInt32(System.Byte[],System.Int32)">
            <summary>
            Returns an int32 from a byte array based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetBEInt32(System.Byte[],System.Int32)">
            <summary>
            Returns an int32 from a byte array based on offset (in BIG ENDIAN format)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetBEInt32FromByteArray(System.Byte[])">
            <summary>
            Returns an int32 from a byte array based on the length of the byte array (in BIG ENDIAN format)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns an int32 from a byte array based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.GetWordValue(System.Byte[],System.Int32)">
            <summary>
            Returns an uint16 from a byte array based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.SetWordValue(System.Byte[],System.Int32,System.UInt16)">
            <summary>
            Updates a byte array with a uint16 value based on offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.TranslatePause(System.Int32)">
            <summary>
            Takes a PauseInMilliseconds value and returns the value in T-States
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.CheckChecksum(System.Byte[],System.Int32)">
            <summary>
            Caluclate a data block XOR checksum
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverter.DecompressZRLE(System.Byte[],System.Byte[]@)">
            <summary>
            Decompresses a byte array that is Z-RLE compressed
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MediaConverterType">
            <summary>
            Represents the different types of media serializer avaiable
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX">
            <summary>
            SZX Methods
            Based on the work done by ArjunNair in ZERO spectrum emulator: https://github.com/ArjunNair/Zero-Emulator/blob/master/Ziggy/Peripherals/SZXFile.cs
            </summary>
            <summary>
            Structs, Constants and Enums
            http://www.spectaculator.com/docs/zx-state/intro.shtml
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ExportSZX(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SpectrumBase)">
            <summary>
            Exports state information to a byte array in ZX-State format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTMF_ALTERNATETIMINGS">
            <summary>
            If set, the emulated Spectrum uses alternate timings (one cycle later than normal timings). If reset, the emulated Spectrum uses standard timings. 
            This flag is only applicable for the ZXSTMID_16K, ZXSTMID_48K and ZXSTMID_128K models.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTHEADER">
            <summary>
            The zx-state header appears right at the start of a zx-state (.szx) file.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTBLOCK">
            <summary>
            Block Header. Each real block starts with this header.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTCREATOR">
            <summary>
            This block identifies the program that created this zx-state file.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTZF_EILAST">
            <summary>
            The last instruction executed was an EI instruction or an invalid $DD or $FD prefix.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTZF_HALTED">
            <summary>
            The last instruction executed was a HALT instruction. The CPU is currently executing NOPs and will continue to do so until the next interrupt occurs. 
            This flag is mutually exclusive with ZXSTZF_EILAST.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTZ80REGS">
            <summary>
            Contains the Z80 registers and other internal state values. It does not contain any specific model registers.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTAYF_FULLERBOX">
            <summary>
            Fuller Box emulation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTAYF_128AY">
            <summary>
            Melodik Soundbox emulation. 
            This is essentially an AY chip for older Spectrums that uses the same ports as that found in 128k Spectrums
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTAYBLOCK">
            <summary>
            The state of the AY chip found in all 128k Spectrums, Pentagons, Scorpions and Timex machines. 
            This block may also be present for 16k/48k Spectrums if Fuller Box or Melodik emulation is enabled.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTRF_COMPRESSED">
            <summary>
            Ram pages are compressed using Zlib
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTRAMPAGE">
            <summary>
            zx-state files will contain a number of 16KB RAM page blocks, depending on the specific Spectrum model.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTKF_ISSUE2">
            <summary>
            Keyboard state
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.JoystickTypes">
            <summary>
            Supported joystick types
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTKEYBOARD">
            <summary>
            The state of the Spectrum keyboard and any keyboard joystick emulation.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTJOYSTICK">
            <summary>
            Joystick setup for both players.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.CassetteRecorderState">
            <summary>
            Cassette Recorder state
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTPLUS3">
            <summary>
            The number of drives connected to the Spectrum +3 and whether their motors are turned on. 
            Any blocks specifying which disk files are in which drive will follow this one.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTDSKF_COMPRESSED">
            <summary>
            Not implemented. All disk images are currently links to external .dsk or .ipf files
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTDSKF_EMBEDDED">
            <summary>
            Not implemented. All disk images are currently links to external .dsk or .ipf files
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTDSKF_SIDEB">
            <summary>
            When a double-sided disk is inserted into a single-sided drive, specifies the side being read from/written to. 
            If set, Side B is the active side, otherwise it is Side A.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.SZX.ZXSTDSKFILE">
            <summary>
            Each +3 disk drive that has a disk inserted in it will have one of these blocks. 
            They follow the ZXSTPLUS3 block which identifies the number of drives.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter">
            <summary>
            Responsible for Compressed Square Wave conversion
            https://web.archive.org/web/20171024182530/http://ramsoft.bbk.org.omegahg.com/csw.html
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter._position">
            <summary>
            Position counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter.CheckType(System.Byte[])">
            <summary>
            Returns TRUE if pzx header is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.CswConverter.ProcessCSWV2(System.Byte[],System.Byte[]@,System.Byte,System.Int32)">
            <summary>
            Processes a CSW v2 data block
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter">
            <summary>
            Reponsible for PZX format serializaton
            Based on the information here:  http://zxds.raxoft.cz/docs/pzx.txt
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter._blocks">
            <summary>
            Working list of generated tape data blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter._position">
            <summary>
            Position counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter._loopCounter">
            <summary>
            Object to keep track of loops - this assumes there is only one loop at a time
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter.CheckType(System.Byte[])">
            <summary>
            Returns TRUE if pzx header is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.PzxConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeCommand">
            <summary>
            Represents the possible commands that can be raised from each tape block
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock">
            <summary>
            Represents a tape block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._blockID">
            <summary>
            Either the TZX block ID, or -1 in the case of non-tzx blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._blockType">
            <summary>
            The block type
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._blockData">
            <summary>
            Byte array containing the raw block data
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.MetaData">
            <summary>
            Dictionary of block related data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.AddMetaData(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.BlockDescriptorTitle,System.String)">
            <summary>
            Adds a single metadata item to the Dictionary
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.DataPeriods">
            <summary>
            List containing the pulse timing values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.DataLevels">
            <summary>
            List containing the pulse levels (in relation to the pulse timing values)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._command">
            <summary>
            Command that is raised by this data block
            (that may or may not need to be acted on)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._pauseInMS">
            <summary>
            The defined post-block pause in MS
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock._pauseInTStates">
            <summary>
            The defined post-block pause in T-States
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.GetDataPeriodsArray">
            <summary>
            Returns the data periods as an array
            (primarily to aid in bizhawk state serialization)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.SetDataPeriodsArray(System.Int32[])">
            <summary>
            Accepts an array of data periods and updates the DataPeriods list accordingly
            (primarily to aid in bizhawk state serialization)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapeDataBlock.SyncState(BizHawk.Common.Serializer,System.Int32)">
            <summary>
            Bizhawk state serialization
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.BlockType">
            <summary>
            The types of TZX blocks
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.BlockDescriptorTitle">
            <summary>
            Different title possibilities
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter">
            <summary>
            Reponsible for TAP format serializaton
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.PILOT_PL">
            <summary>
            Pilot pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.HEADER_PILOT_COUNT">
            <summary>
            Pilot pulses in the ROM header block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.DATA_PILOT_COUNT">
            <summary>
            Pilot pulses in the ROM data block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.SYNC_1_PL">
            <summary>
            Sync 1 pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.SYNC_2_PL">
            <summary>
            Sync 2 pulse lenth
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.BIT_0_PL">
            <summary>
            Bit 0 pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.BIT_1_PL">
            <summary>
            Bit 1 pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.TERM_SYNC">
            <summary>
            End sync pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.PAUSE_MS">
            <summary>
            1 millisecond pause
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.BIT_COUNT_IN_LAST">
            <summary>
            Used bit count in last byte
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TapConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter">
            <summary>
            Reponsible for TZX format serializaton
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter._blocks">
            <summary>
            Working list of generated tape data blocks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter._position">
            <summary>
            Position counter
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter._loopCounter">
            <summary>
            Object to keep track of loops - this assumes there is only one loop at a time
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter._datacorder">
            <summary>
            The virtual cassette deck
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.CheckType(System.Byte[])">
            <summary>
            Returns TRUE if tzx header is detected
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.data">
            <summary>
            The raw TZX data array
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.t">
            <summary>
            The current BizHawk TapeDataBlock object
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.blockId">
            <summary>
            Block ID of the current TZX block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.blockLen">
            <summary>
            The length of the data in the current block (in bytes)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.pilotToneLength">
            <summary>
            Length of the pilot tone in pulses (half-periods)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.sync1PulseLength">
            <summary>
            Length of the syncro first pulse
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.sync2PulseLength">
            <summary>
            Length of the syncro second pulse
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.bit0PulseLength">
            <summary>
            Length of the zero bit pulse
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.bit1PulseLength">
            <summary>
            Length of the one bit pulse length
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.pilotCount">
            <summary>
            Length of pilot tone (number of pulses or half-periods)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.bitsInLastByte">
            <summary>
            Used bits in the last byte (MSb first)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.pauseLen">
            <summary>
            Pause length (in ms) after this block
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.signal">
            <summary>
            Represents whether the current signal is HIGH (true) or LOW (false)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.bitCount">
            <summary>
            Remaining bits in current byte to process
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ToggleSignal">
            <summary>
            Inverts the audio signal
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlock">
            <summary>
            Processes a TZX block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID10">
            <summary>
            0x10 - Standard Data Block (ROM)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID11">
            <summary>
            0x11 - Custom Data Block (Turbo)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID12">
            <summary>
            0x12 - Pure Tone
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID13">
            <summary>
            0x13 - Pulse Sequence
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID14">
            <summary>
            0x14 - Pure Data BLock
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID15">
            <summary>
            0x15 - Direct Recording Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID18">
            <summary>
            0x18 - CSW Recording Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID20">
            <summary>
            Pause Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID21">
            <summary>
            0x21 - Group Start
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID22">
            <summary>
            0x22 - Group End
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID24">
            <summary>
            0x24 - Loop Start
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID25">
            <summary>
            0x25 - Loop End
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID2A">
            <summary>
            0x2A - Stop the Tape if in 48K Mode
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID2B">
            <summary>
            0x2B - Set Signal Level
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID30">
            <summary>
            Text Description
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID32">
            <summary>
            0x32 - Archive Info
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID35">
            <summary>
            0x35 - Custom Info Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID5A">
            <summary>
            0x5A - Glue Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessUnidentifiedBlock">
            <summary>
            Skips an unknown block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID33">
            <summary>
            0x33 - Hardware Type
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID31">
            <summary>
            0x31 - Message Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID26">
            <summary>
            0x26 - Call Sequence
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID27">
            <summary>
            0x27 - Return From Sequence
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID28">
            <summary>
            0x28 - Select Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID23">
            <summary>
            0x23 - Jump to Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ProcessBlockID19">
            <summary>
            0x19 - Generalized Data Block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.ZeroVars">
            <summary>
            Sets up variables for the next block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.DecodeData">
            <summary>
            Decode method for standard, turbo and pure data blocks
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.TzxConverter.DoPause">
            <summary>
            Generates pause data
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.StreamHelper">
            <summary>
            From https://archive.codeplex.com/?p=zxmak2
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter">
            <summary>
            Reponsible for WAV format conversion
            Based heavily on code from zxmak2: https://archive.codeplex.com/?p=zxmak2
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter._formatType">
            <summary>
            The type of serializer
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter.IsReader">
            <summary>
            Signs whether this class can be used to read the data format
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter.IsWriter">
            <summary>
            Signs whether this class can be used to write the data format
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter._datacorder">
            <summary>
            Position counter
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter.CheckType(System.Byte[])">
            <summary>
            Returns TRUE if pzx header is detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavConverter.Read(System.Byte[])">
            <summary>
            DeSerialization method
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavHeader">
            <summary>
            From https://archive.codeplex.com/?p=zxmak2
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.WavStreamReader">
            <summary>
            From https://archive.codeplex.com/?p=zxmak2
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum">
            <summary>
            ZXHawk: Core Class
            * Controllers *
            </summary>
            <summary>
            ZXHawk: Core Class
            * Main Initialization *
            </summary>
            <summary>
            ZXHawk: Core Class
            * ICodeDataLog *
            </summary>
            <summary>
            ZXHawk: Core Class
            * IDebuggable *
            </summary>
            <summary>
            ZXHawk: Core Class
            * IEmulator *
            </summary>
            <summary>
            ZXHawk: Core Class
            * IInputPollable *
            </summary>
            <summary>
            ZXHawk: Core Class
            * Memory Domains *
            </summary>
            <summary>
            ZXHawk: Core Class
            * ISettable *
            </summary>
            <summary>
            ZXHawk: Core Class
            * IStatable *
            </summary>
            <summary>
            ZXHawk: Core Class
            * Handles all messaging (OSD) operations *
            </summary>
            <summary>
            ZXHawk: Core Class
            * Misc Utilities *
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.ZXSpectrumControllerDefinition">
            <summary>
            The one ZX Hawk ControllerDefinition
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSDVerbosity">
            <summary>
            Verbosity of the ZXHawk generated OSD messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSDVerbosity.Full">
            <summary>
            Show all OSD messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSDVerbosity.Medium">
            <summary>
            Only show machine/device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSDVerbosity.None">
            <summary>
            No core-driven OSD messages
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType">
            <summary>
            The size of the Spectrum border
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType.Full">
            <summary>
            How it was originally back in the day
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType.Medium">
            <summary>
            All borders 24px
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType.Small">
            <summary>
            All borders 10px
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType.None">
            <summary>
            No border at all
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.BorderType.Widescreen">
            <summary>
            Top and bottom border removed so that the result is *almost* 16:9
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.TapeLoadSpeed">
            <summary>
            The speed at which the tape is loaded
            NOT IN USE YET
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.SendMessage(System.String,BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory)">
            <summary>
            Writes a message to the OSD
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_FireInputMessage(System.String)">
            <summary>
            Called when certain input presses are detected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_DiskInit">
            <summary>
            Disk message that is fired on core init
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_DiskInserted">
            <summary>
            Disk message that is fired when a new disk is inserted into the drive
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_ShowDiskStatus">
            <summary>
            Tape message that prints the current status of the tape device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeInit">
            <summary>
            Tape message that is fired on core init
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapePlaying">
            <summary>
            Tape message that is fired when tape is playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeStopped">
            <summary>
            Tape message that is fired when tape is stopped
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeRTZ">
            <summary>
            Tape message that is fired when tape is rewound
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeInserted">
            <summary>
            Tape message that is fired when a new tape is inserted into the datacorder
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeStoppedAuto">
            <summary>
            Tape message that is fired when a tape is stopped automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapePlayingAuto">
            <summary>
            Tape message that is fired when a tape is started automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapePlayingBlockInfo(System.String)">
            <summary>
            Tape message that is fired when a new block starts playing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapePlayingSkipBlockInfo(System.String)">
            <summary>
            Tape message that is fired when a tape block is skipped (because it is empty)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeEndDetected(System.String)">
            <summary>
            Tape message that is fired when a tape is started automatically
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapeNextBlock(System.String)">
            <summary>
            Tape message that is fired when user has manually skipped to the next block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_TapePrevBlock(System.String)">
            <summary>
            Tape message that is fired when user has manually skipped to the next block
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.OSD_ShowTapeStatus">
            <summary>
            Tape message that prints the current status of the tape device
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.CheckMessageSettings(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory)">
            <summary>
            Checks whether message category is allowed to be sent
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory">
            <summary>
            Defines the different message categories
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory.Misc">
            <summary>
            No defined category as such
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory.Input">
            <summary>
            User generated input messages (at the moment only tape/disk controls)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory.Tape">
            <summary>
            Tape device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory.Disk">
            <summary>
            Disk device generated messages
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.MessageCategory.Emulator">
            <summary>
            Emulator generated messages
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.GetIntFromBitArray(System.Collections.BitArray)">
            <summary>
            Helper method that returns a single INT32 from a BitArray
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.PokeMemory(System.UInt16,System.Byte)">
            <summary>
            POKEs a memory bus address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.GetMachineType">
            <summary>
            Called by MainForm so that the core label can display a more detailed tooltip about the emulated spectrum model
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.GetSZXSnapshot">
            <summary>
            Called by MainForm - dumps a close approximation of the Spectaculator SZX snapshot format
            DEV use only - this is nowhere near accurate
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXSpectrum.GetMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Utility method to get MemberName from an object
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.JoystickType">
            <summary>
            The possible joystick types
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXMachineMetaData">
            <summary>
            Provides information on each emulated machine
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXMachineMetaData.GetMetaObject(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType)">
            <summary>
            Detailed info to be displayed within the settings UIs
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Computers.SinclairSpectrum.ZXMachineMetaData.GetMetaString(BizHawk.Emulation.Cores.Computers.SinclairSpectrum.MachineType)">
            <summary>
            Returns machine metadata as a formatted string (to be displayed in a TextBox)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.IPort">
            <summary>
            Represents a controller plugged into a controller port on the 2600
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.mDPCPlus">
            	Cartridge class used for DPC+.  There are six 4K program banks, a 4K
            	display bank, 1K frequency table and the DPC chip.  For complete details on
            	the DPC chip see David P. Crane's United States Patent Number 4,644,495.
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.mEFSC">
            	Cartridge class used for Homestar Runner by Paul Slocum.
            	There are 16 4K banks (total of 64K ROM) with 128 bytes of RAM.
            	Accessing $1FE0 - $1FEF switches to each bank.
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.mF4SC">
            	Cartridge class used for Atari's 16K bankswitched games with
            	128 bytes of RAM.  There are four 4K banks.
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.mF6SC">
            	Cartridge class used for Atari's 16K bankswitched games with
            	128 bytes of RAM.  There are four 4K banks.
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Atari2600.mF8SC">
            	Cartridge class used for Atari's 8K bankswitched games with
            	128 bytes of RAM.  There are two 4K banks.
        </member>
        <member name="M:BizHawk.Emulation.Cores.Atari.Atari2600.TIA.Audio.Cycle_L">
            <summary>
            call me approx 31k times a second
            </summary>
            <returns>16 bit audio sample</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Atari.Atari2600.TIA.Audio.Cycle_R">
            <summary>
            call me approx 31k times a second
            </summary>
            <returns>16 bit audio sample</returns>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Atari.Atari2600.TIA.LineCount">
            <summary>
            Gets or sets a count of lines emulated; incremented by the TIA but not used by it
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.A7800Hawk.IPort">
            <summary>
            Represents a controller plugged into a controller port on the A7800
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Atari.A7800Hawk.TIA.Audio.Cycle">
            <summary>
            call me approx 31k times a second
            </summary>
            <returns>16 bit audio sample</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Atari.Stella.Stella.LoadCallback(System.String,System.IntPtr,System.Int32)">
            <summary>
            core callback for file loading
            </summary>
            <param name="filename">string identifying file to be loaded</param>
            <param name="buffer">buffer to load file to</param>
            <param name="maxsize">maximum length buffer can hold</param>
            <returns>actual size loaded, or 0 on failure</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Atari.Stella.IPort">
            <summary>
            Represents a controller plugged into a controller port on the 2600
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.MapperHANG">
            <summary>
            Hangman ChannelF Cartridge
            Utilises 2102 SRAM over IO
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.MapperMAZE">
            <summary>
            Maze ChannelF Cartridge
            Utilises 2102 SRAM over IO
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.MapperRIDDLE">
            <summary>
            Sean Riddle's modified SCHACH cart mapper (multi-cart)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.MapperSCHACH">
            <summary>
            Saba Schach Mapper
            Any size ROM / 2KB RAM mapped at 0x2800 - 0x2FFF
            Info here: http://www.seanriddle.com/chanfmulti.html
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.MapperSTD">
            <summary>
            Standard ChannelF Cartridge
            2KB ROM / NO RAM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.VesCartBase.SRAM2102_Read(System.Int32)">
            <summary>
            Read method for carts that have an IO-accessible 2102 SRAM chip
            Based on: https://github.com/mamedev/mame/blob/ee1e4f9683a4953cb9d88f9256017fcbc38e3144/src/devices/bus/chanf/rom.cpp
            license:BSD-3-Clause
            copyright-holders:Fabio Priuli
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.VesCartBase.SRAM2102_Write(System.Int32,System.Byte)">
            <summary>
            Write method for carts that have an IO-accessible 2102 SRAM chip
            Based on: https://github.com/mamedev/mame/blob/ee1e4f9683a4953cb9d88f9256017fcbc38e3144/src/devices/bus/chanf/rom.cpp
            license:BSD-3-Clause
            copyright-holders:Fabio Priuli
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF">
            <summary>
            Sound related functions
            </summary>
            <summary>
            Memory and related functions
            </summary>
            <summary>
            Ports and related functions
            Based on the schematic here:
            https://web.archive.org/web/20210524083636/http://channelf.se/veswiki/images/3/31/FVE100_schematic_sheet_1of3.gif
            https://web.archive.org/web/20160313115333/http://channelf.se/veswiki/images/0/04/FVE_schematic_sheet_2_of_3.png
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.PollInput">
            <summary>
            Cycles through all the input callbacks
            This should be done once per frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.ViewPort.AllVisible">
            <summary>
            View the entire screen minus flyback areas
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.ViewPort.Trimmed">
            <summary>
            Trimmed viewport for a more centred display
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF._vram">
            <summary>
            128x64 pixels - 8192x2bits (2 KB)
            For the purposes of this core we will use 8192 bytes and just mask 0x03
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.ClockVideo">
            <summary>
            Called after every CPU clock
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.ReadBus(System.UInt16)">
            <summary>
            Simulates reading a byte of data from the address space
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.WriteBus(System.UInt16,System.Byte)">
            <summary>
            Simulates writing a byte of data to the address space (in its default configuration, there is no writeable RAM in the
            Channel F addressable through the address space)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF._outputLatch">
            <summary>
            The Channel F has 4 8-bit IO ports connected.
            CPU (3850) - ports 0 and 1
            PSU (3851) - ports 4 and 5
            (the second PSU has no IO ports wired up)
            Depending on the attached cartridge, there may be additional hardware on the IO bus
            All CPU and PSU I/O ports are active-low with output-latches
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.ReadPort(System.UInt16)">
            <summary>
            CPU is attempting to read from a port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.ChannelF.ChannelF.WritePort(System.UInt16,System.Byte)">
            <summary>
            CPU is attempting to write to the specified IO port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Vectrex.VectrexHawk.FetchMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for FetchMemory which inserts CDL logic
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Vectrex.VectrexHawk.ReadMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for ReadMemory which inserts CDL logic
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.Vectrex.IPort">
            <summary>
            Represents a Vectrex add on
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.O2Hawk.IPort">
            <summary>
            Represents a O2 add on
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.Nintendo.N3DS.Encore.EncoreSyncSettings.EGraphicsApi">
            <summary>
            TOOD: Vulkan support
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.ScanlineCallback">
            <param name="lcdc">current value of register $ff40 (LCDC)</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.PrinterCallback">
            <param name="image">The image data</param>
            <param name="height">How tall an image is, in pixels. Image is only valid up to that height and must be assumed to be garbage below that.</param>
            <param name="top_margin">The top margin of blank pixels. Just form feeds the printer a certain amount at the top.</param>
            <param name="bottom_margin">The bottom margin of blank pixels. Just form feeds the printer a certain amount at the bottom.</param>
            <param name="exposure">The darkness/intensity of the print job. What the exact values mean is somewhat subjective but 127 is the most exposed/darkest value.</param>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.ILinkedGameBoyCommon.First">
            <remarks>really just for RetroAchivements; can be changed to a list later</remarks>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.IGameboyCommon.IsCGBMode">
            <value><see langword="true"/> iff the emulator is currently emulating CGB</value>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.IGameboyCommon.IsCGBDMGMode">
            <value><see langword="true"/> iff the emulator is currently emulating CGB in DMG compatibility mode</value>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.IGameboyCommon.LockGPU">
            <summary>
            Acquire GPU memory for inspection.  The returned object must be disposed as soon as the frontend
            tool is done inspecting it, and the pointers become invalid once it is disposed.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.IGameboyCommon.SetScanlineCallback(BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.ScanlineCallback,System.Int32)">
            <summary>
            set up callback
            </summary>
            <param name="line">scanline. -1 = end of frame, -2 = RIGHT NOW</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.IGameboyCommon.SetPrinterCallback(BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.PrinterCallback)">
            <summary>
            Set up printer callback
            </summary>
            <param name="callback">The callback to get the image. Setting this to non-null also "connects" the printer as the serial device.</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_new">
            <summary>
            create a new quicknes context
            </summary>
            <returns>NULL on failure</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_delete(System.IntPtr)">
            <summary>
            destroy a quicknes context
            </summary>
            <param name="e">context previously returned from qn_new()</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_loadines(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            load an ines file
            </summary>
            <param name="e">context</param>
            <param name="data">file</param>
            <param name="length">length of file</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_set_sample_rate(System.IntPtr,System.Int32)">
            <summary>
            set audio sample rate
            </summary>
            <param name="e">context</param>
            <param name="rate">hz</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_emulate_frame(System.IntPtr,System.UInt32,System.UInt32,System.Byte,System.Byte,System.UInt32)">
            <summary>
            emulate a single frame
            </summary>
            <param name="e">context</param>
            <param name="pad1">pad 1 input</param>
            <param name="pad2">pad 2 input</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_blit(System.IntPtr,System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            blit to rgb32
            </summary>
            <param name="e">Context</param>
            <param name="dest">rgb32 256x240 packed</param>
            <param name="colors">rgb32 colors, 512 of them</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_default_colors">
            <summary>
            get quicknes's default palette
            </summary>
            <returns>1536 bytes suitable for qn_blit</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_joypad_read_count(System.IntPtr)">
            <summary>
            get number of times joypad was read in most recent frame
            </summary>
            <param name="e">context</param>
            <returns>0 means lag</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_audio_info(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            get audio info for most recent frame
            </summary>
            <param name="e">context</param>
            <param name="sample_count">number of samples actually created</param>
            <param name="chan_count">1 for mono, 2 for stereo</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_read_audio(System.IntPtr,System.Int16[],System.Int32)">
            <summary>
            get audio for most recent frame.  must not be called more than once per frame!
            </summary>
            <param name="e">context</param>
            <param name="dest">sample buffer</param>
            <param name="max_samples">length to read into sample buffer</param>
            <returns>length actually read</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_reset(System.IntPtr,System.Boolean)">
            <summary>
            reset the console
            </summary>
            <param name="e">context</param>
            <param name="hard">true for powercycle, false for reset button</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_state_size(System.IntPtr,System.Int32@)">
            <summary>
            get the required byte size of a savestate
            </summary>
            <param name="e">context</param>
            <param name="size">size is returned</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_state_save(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            save state to buffer
            </summary>
            <param name="e">context</param>
            <param name="dest">buffer</param>
            <param name="size">length of buffer</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_state_load(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            load state from buffer
            </summary>
            <param name="e">context</param>
            <param name="src">buffer</param>
            <param name="size">length of buffer</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_has_battery_ram(System.IntPtr)">
            <summary>
            query battery ram state
            </summary>
            <param name="e">context</param>
            <returns>true if battery backup sram exists</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_battery_ram_size(System.IntPtr,System.Int32@)">
            <summary>
            query battery ram size
            </summary>
            <param name="e">context</param>
            <param name="size">size is returned</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_battery_ram_save(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            save battery ram to buffer
            </summary>
            <param name="e">context</param>
            <param name="dest">buffer</param>
            <param name="size">size</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_battery_ram_load(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            load battery ram from buffer
            </summary>
            <param name="e">context</param>
            <param name="src">buffer</param>
            <param name="size">size</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_battery_ram_clear(System.IntPtr)">
            <summary>
            clear battery ram
            </summary>
            <param name="e">context</param>
            <returns>string error</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_set_sprite_limit(System.IntPtr,System.Int32)">
            <summary>
            set sprite limit; does not affect emulation
            </summary>
            <param name="e">context</param>
            <param name="n">0 to hide, 8 for normal, 64 for all</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_memory_area(System.IntPtr,System.Int32,System.IntPtr@,System.Int32@,System.Boolean@,System.IntPtr@)">
            <summary>
            get memory area for debugging
            </summary>
            <param name="e">Context</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_peek_prgbus(System.IntPtr,System.Int32)">
            <summary>
            peek the system bus
            </summary>
            <param name="e">Context</param>
            <param name="addr">0000:ffff, but non-ram/rom addresses won't work</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_poke_prgbus(System.IntPtr,System.Int32,System.Byte)">
            <summary>
            poke the system bus
            </summary>
            <param name="e">Context</param>
            <param name="addr">0000:ffff, but non-ram/rom addresses won't work</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_cpuregs(System.IntPtr,System.Int32[])">
            <summary>
            get internal registers
            </summary>
            <param name="e">Context</param>
            <param name="dest">a, x, y, sp, pc, p</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_get_mapper(System.IntPtr,System.Int32@)">
            <summary>
            get the mapper that's loaded
            </summary>
            <param name="e">Context</param>
            <param name="number">recieves mapper number</param>
            <returns>mapper name</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.qn_set_tracecb(System.IntPtr,BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.TraceCallback)">
            <summary>
            set a trace callback to be run on each cycle
            </summary>
            <param name="e">Context</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.LibQuickNES.ThrowStringError(System.IntPtr)">
            <summary>
            handle "string error" as returned by some quicknes functions
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.QuickNES._syncSettings">
            <summary>
            the syncsettings that this run of emulation is using (was passed to ctor)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Nintendo.QuickNES.QuickNES._syncSettingsNext">
            <summary>
            the syncsettings that were requested but won't be used yet
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.GPGX.LoadArchive(System.String,System.IntPtr,System.Int32)">
            <summary>
            core callback for file loading
            </summary>
            <param name="filename">string identifying file to be loaded</param>
            <param name="buffer">buffer to load file to</param>
            <param name="maxsize">maximum length buffer can hold</param>
            <returns>actual size loaded, or 0 on failure</returns>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.GPGX._inputSize">
            <summary>
            size of native input struct
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.GPGXControlConverter.ScreenWidth">
            <summary>
            must be set for proper lightgun operation
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.GPGXControlConverter.ScreenHeight">
            <summary>
            must be set for proper lightgun operation
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.INPUT_KEYS">
            <summary>
            not every flag is valid for every device!
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.InputData.pad">
            <summary>
            digital inputs
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.InputData.analog">
            <summary>
            analog (x/y)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.InputData.x_offset">
            <summary>
            gun horizontal offset
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.InputData.y_offset">
            <summary>
            gun vertical offset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.gpgx_flush_vram">
            <summary>
            regenerate whatever portions of the bg pattern cache are currently dirty.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Sega.gpgx.LibGPGX.gpgx_invalidate_pattern_cache">
            <summary>
            mark the bg pattern cache as dirty
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Consoles.Sega.PicoDrive.LibPicoDrive.Init(System.Boolean,System.Boolean,BizHawk.Emulation.Cores.Consoles.Sega.PicoDrive.LibPicoDrive.Region,BizHawk.Emulation.Cores.Consoles.Sega.PicoDrive.LibPicoDrive.Region)">
            <param name="cd">If TRUE, load a CD and not a cart.</param>
            <param name="_32xPreinit">If TRUE, preallocate 32X data structures.  When set to false,
            	32X games will still run, but will not have memory domains</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.ColecoVision.IPort">
            <summary>
            Represents a controller plugged into a controller port on the Colecovision
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Intellivision.IPort">
            <summary>
            Represents a controller plugged into a controller port on the intellivision
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.BSNES.BsnesApi.BSNES_PORT1_INPUT_DEVICE">
            this a subset of the <see cref="T:BizHawk.Emulation.Cores.Nintendo.BSNES.BsnesApi.BSNES_INPUT_DEVICE"/> enum with all lightgun controllers removed
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.BSNES.IBsnesController.GetState(BizHawk.Emulation.Common.IController,System.Int32,System.Int32)">
            <summary>
            Corresponds to an InputPoll call from the core; gets called potentially many times per frame
            </summary>
            <param name="index">bsnes specific value, sometimes multitap number</param>
            <param name="id">bsnes specific value, sometimes button number</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.BSNES.BsnesPayloadController">
            <summary>
            "Virtual" controller that behaves like a multitap controller, but with 16 instead of 12 buttons per controller.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.BSNES.BsnesCore.snes_input_poll(System.Int32,System.Int32,System.Int32)">
            <param name="port">0 or 1, corresponding to L and R physical ports on the snes</param>
            <param name="index">meaningless for most controllers.  for multitap, 0-3 for which multitap controller</param>
            <param name="id">button ID enum; in the case of a regular controller, this corresponds to shift register position</param>
            <returns>for regular controllers, one bit D0 of button status.  for other controls, varying ranges depending on id</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy">
            <summary>
            a gameboy/gameboy color emulator wrapped around native C++ libgambatte
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.TestromsBIOSDisableHack">
            <remarks>HACK disables BIOS requirement if the environment looks like a test runner...</remarks>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.TICKSINFRAME">
            <summary>
            the nominal length of one frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.TICKSPERSECOND">
            <summary>
            number of ticks per second
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.ResetStallTicks">
            <summary>
            number of reset stall ticks
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.InputCallback">
            <summary>
            keep a copy of the input callback delegate so it doesn't get GCed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.CurrentButtons">
            <summary>
            whatever keys are currently depressed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.RemoteCallback">
            <summary>
            remote callback delegate
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.RemoteCommand">
            <summary>
            remote command to send
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.GambatteState">
            <summary>
            internal gambatte state
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy._cycleCount">
            <summary>
            total cycles actually executed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.frameOverflow">
            <summary>
            number of extra cycles we overran in the last frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.ConnectInputCallbackSystem(BizHawk.Emulation.Common.InputCallbackSystem)">
            <summary>
            for use in dual core
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.SetScanlineCallback(BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.ScanlineCallback,System.Int32)">
            <summary>
            set up callback
            </summary>
            <param name="line">scanline. -1 = end of frame, -2 = RIGHT NOW</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.SetPrinterCallback(BizHawk.Emulation.Cores.Consoles.Nintendo.Gameboy.PrinterCallback)">
            <summary>
            set up Printer callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.ChangeDMGColors(System.Int32[])">
            <summary>
            update gambatte core's internal colors
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.ConnectMemoryCallbackSystem(BizHawk.Emulation.Common.MemoryCallbackSystem,System.Int32)">
            <summary>
            for use in dual core
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.GambatteSettings.Muted">
            <summary>
            true to mute all audio
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.GambatteSettings.RgbdsSyntax">
            <summary>
            true to use rgbds syntax
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.GambatteSettings.ShowBorder">
            <summary>
            true to show sgb border (sgb mode only)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.FrameBuffer">
            <summary>
            buffer of last frame produced
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.VideoBuffer">
            <summary>
            stored image of most recent frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.Gameboy.SgbVideoBuffer">
            <summary>
            stored image of most recent sgb frame
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.GambattePrinter">
            <summary>
            Emulate the gameboy printer in managed code
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte">
            <summary>
            static bindings into libgambatte.dll
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_create">
            <returns>opaque state pointer</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_destroy(System.IntPtr)">
            <param name="core">opaque state pointer</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.CGB_MODE">
            <summary>Treat the ROM as having CGB support regardless of what its header advertises</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.GBA_FLAG">
            <summary>Use GBA intial CPU register values when in CGB mode.</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.RESERVED_FLAG">
            <summary>Previously a multicart heuristic enable. Reserved for future use.</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.SGB_MODE">
            <summary>Treat the ROM as having SGB support regardless of what its header advertises.</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.READONLY_SAV">
            <summary>Prevent implicit saveSavedata calls for the ROM.</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags.NO_BIOS">
            <summary>Use heuristics to boot without a BIOS.</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_loadbuf(System.IntPtr,System.Byte[],System.UInt32,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LoadFlags)">
            <summary>
            Load ROM image.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="romdata">the rom data, can be disposed of once this function returns</param>
            <param name="length">length of romdata in bytes</param>
            <param name="flags">ORed combination of LoadFlags.</param>
            <returns>0 on success, negative value on failure.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_loadbiosbuf(System.IntPtr,System.Byte[],System.UInt32)">
            <summary>
            Load GB(C) BIOS image.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="biosdata">the bios data, can be disposed of once this function returns</param>
            <param name="length">length of romdata in bytes</param>
            <returns>0 on success, negative value on failure.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_runfor(System.IntPtr,System.Int32[],System.Int32,System.Int16[],System.UInt32@)">
            <summary>
            Emulates until at least 'samples' stereo sound samples are produced in the supplied buffer,
            or until a video frame has been drawn.
            
            There are 35112 stereo sound samples in a video frame.
            May run for up to 2064 stereo samples too long.
            A stereo sample consists of two native endian 2s complement 16-bit PCM samples,
            with the left sample preceding the right one.
            
            Returns early when a new video frame has finished drawing in the video buffer,
            such that the caller may update the video output before the frame is overwritten.
            The return value indicates whether a new video frame has been drawn, and the
            exact time (in number of samples) at which it was drawn.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="videobuf">160x144 RGB32 (native endian) video frame buffer or 0</param>
            <param name="pitch">distance in number of pixels (not bytes) from the start of one line to the next in videoBuf</param>
            <param name="soundbuf">buffer with space >= samples + 2064</param>
            <param name="samples">in: number of stereo samples to produce, out: actual number of samples produced</param>
            <returns>sample number at which the video frame was produced. -1 means no frame was produced.</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_reset(System.IntPtr,System.UInt32)">
            <summary>
            Reset to initial state.
            Equivalent to reloading a ROM image, or turning a Game Boy Color off and on again.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="samplesToStall">samples of reset stall</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.PalType">
            <summary>
            palette type for gambatte_setdmgpalettecolor
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setdmgpalettecolor(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.PalType,System.UInt32,System.UInt32)">
            <param name="core">opaque state pointer</param>
            <param name="palnum">in [0, 2]: One of BG_PALETTE, SP1_PALETTE and SP2_PALETTE.</param>
            <param name="colornum">in [0, 3]</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setcgbpalette(System.IntPtr,System.Int32[])">
            <summary>
            set cgb palette lookup
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="lut">uint32[32768], input color (r,g,b) is at lut[r | g &lt;&lt; 5 | b &lt;&lt; 10]</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.Buttons">
            <summary>
            combination of button flags used by the input callback
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.InputGetter">
            <summary>
            type of the callback for input state
            </summary>
            <returns>bitfield combination of pressed buttons</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setinputgetter(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.InputGetter,System.IntPtr)">
            <summary>
            Sets the callback used for getting input state.
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getjoypadindex(System.IntPtr)">
            <summary>
            Gets which SGB controller is in use, 0 indexed.
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryCallback">
            <summary>
            type of the read\write memory callbacks
            </summary>
            <param name="address">the address which the cpu is read\writing</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.CDCallback">
            <summary>
            type of the CDLogger callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setreadcallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryCallback)">
            <summary>
            set a callback to occur immediately BEFORE EVERY cpu read, except for opcode first byte fetches
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setwritecallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryCallback)">
            <summary>
            set a callback to occur immediately AFTER EVERY cpu write
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setexeccallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryCallback)">
            <summary>
            set a callback to occur immediately BEFORE EVERY cpu opcode (first byte) fetch
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setcdcallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.CDCallback)">
            <summary>
            set a callback whicih enables CD Logger feedback
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.TraceCallback">
            <summary>
            type of the cpu trace callback
            </summary>
            <param name="state">cpu state</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_settracecallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.TraceCallback)">
            <summary>
            set a callback to occur immediately BEFORE each opcode is executed
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setlayers(System.IntPtr,System.Int32)">
            <summary>
            sets layers to be rendered
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="mask">layermask, 1=BG, 2=OBJ, 4=WINDOW</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.ScanlineCallback">
            <summary>
            type of the scanline callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setscanlinecallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.ScanlineCallback,System.Int32)">
            <summary>
            set a callback to occur when ly reaches a particular scanline (so at the beginning of the scanline).
            when the LCD is active, typically 145 will be the first callback after the beginning of frame advance,
            and 144 will be the last callback right before frame advance returns
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">null to clear</param>
            <param name="sl">0-153 inclusive</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LinkCallback">
            <summary>
            type of the link data sent callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setlinkcallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.LinkCallback)">
            <summary>
            sets the Link data sent callback.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">the callback</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.CameraCallback">
            <summary>
            type of the camera data request callback
            </summary>
            <param name="cameraBuf">pointer to camera buffer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setcameracallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.CameraCallback)">
            <summary>
            sets the camera data request callback.
            the callback will receive the pointer to the buffer.
            a 128x112 native endian rgb32 image should be copied to the buffer.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">the callback</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.RemoteCallback">
            <summary>
            type of the remote input callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setremotecallback(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.RemoteCallback)">
            <summary>
            sets the remote input callback.
            the callback will return a value from 0 to 127.
            this value represents a remote command.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="callback">the callback</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_settimemode(System.IntPtr,System.Boolean)">
            <summary>
            Changes between cycle-based and real-time RTC. Defaults to cycle-based.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="useCycles">use cycle-based RTC</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setrtcdivisoroffset(System.IntPtr,System.Int32)">
            <summary>
            Adjusts the CPU clock frequency relative to real time. Base value is 2^22 Hz.
            This is used to account for drift in the RTC when syncing cycle-based RTC to real hardware.
            RTCs in carts are not perfectly accurate, and the value will differ from cart to cart.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="rtcDivisorOffset">CPU frequency adjustment</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setcartbuspulluptime(System.IntPtr,System.UInt32)">
            <summary>
            Sets how long until the cart bus pulls up in CPU cycles.
            This is used to account for differences in pull-up times between carts/consoles.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="cartBusPullUpTime">Pull-Up Time</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_iscgb(System.IntPtr)">
            <summary>
            Returns true if the currently loaded ROM image is treated as having CGB support.
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_iscgbdmg(System.IntPtr)">
            <summary>
            Returns true if the currently loaded ROM image is treated as having CGB-DMG support.
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_isloaded(System.IntPtr)">
            <summary>
            Returns true if a ROM image is loaded.
            </summary>
            <param name="core">opaque state pointer</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_savesavedata(System.IntPtr,System.Byte[])">
            <summary>
            Get persistant cart memory.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="dest">byte buffer to write into.  gambatte_savesavedatalength() bytes will be written</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_loadsavedata(System.IntPtr,System.Byte[])">
            <summary>
            restore persistant cart memory.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="data">byte buffer to read from.  gambatte_savesavedatalength() bytes will be read</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getsavedatalength(System.IntPtr)">
            <summary>
            get the size of the persistant cart memory block.  this value DEPENDS ON THE PARTICULAR CART LOADED
            </summary>
            <param name="core">opaque state pointer</param>
            <returns>length in bytes.  0 means no internal persistant cart memory</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_newstatelen(System.IntPtr)">
            <summary>
            new savestate method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_newstatesave(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            new savestate method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_newstateload(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            new savestate method
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_romtitle(System.IntPtr,System.Byte[])">
            <summary>
            ROM header title of currently loaded ROM image.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="data">enough room for 16 ascii chars plus terminator</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_pakinfo(System.IntPtr,System.Byte[],System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Pakinfo of currently loaded ROM image.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="mbc">enough room for 32 ascii chars plus terminator</param>
            <param name="rambanks">number of rambanks</param>
            <param name="rombanks">number of rombanks</param>
            <param name="crc">core reported crc32</param>
            <param name="headerchecksumok">core reported header checksum status</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryAreas">
            <summary>
            memory areas that gambatte_getmemoryarea() can return
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getmemoryarea(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.MemoryAreas,System.IntPtr@,System.Int32@)">
            <summary>
            get pointer to internal memory areas, for debugging purposes
            so long as you don't write to it, you should be completely sync-safe
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="which">which memory area to access</param>
            <param name="data">pointer to the start of the area</param>
            <param name="length">valid length of the area, in bytes</param>
            <returns>success</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_savestate(System.IntPtr,System.Int32[],System.Int32,System.Byte[])">
            <summary>
            Saves emulator state to the buffer given by 'stateBuf'.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="videoBuf">160x144 RGB32 (native endian) video frame buffer or 0. Used for saving a thumbnail.</param>
            <param name="pitch">pitch distance in number of pixels (not bytes) from the start of one line to the next in videoBuf.</param>
            <param name="stateBuf">buffer for savestate</param>
            <returns>size</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_loadstate(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            Loads emulator state from the buffer given by 'stateBuf' of size 'size'.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="stateBuf">buffer for savestate</param>
            <param name="size">size of savestate buffer</param>
            <returns>success</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_cpuread(System.IntPtr,System.UInt16)">
            <summary>
            read a single byte from the cpu bus.  this includes all ram, rom, mmio, etc, as it is visible to the cpu (including mappers).
            while there is no cycle cost to these reads, there may be other side effects!  use at your own risk.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">system bus address</param>
            <returns>byte read</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_cpuwrite(System.IntPtr,System.UInt16,System.Byte)">
            <summary>
            write a single byte to the cpu bus.  while there is no cycle cost to these writes, there can be quite a few side effects.
            use at your own risk.
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">system bus address</param>
            <param name="val">byte to write</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_linkstatus(System.IntPtr,System.Int32)">
            <summary>
            link cable stuff; never touch for normal operation
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="which">todo</param>
            <returns>todo</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getbank(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.BankType)">
            <summary>
            get current bank for type of memory
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="type">type of memory</param>
            <returns>current bank</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getaddrbank(System.IntPtr,System.UInt16)">
            <summary>
            get current bank for type of memory at address
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">address for memory type</param>
            <returns>current bank, or 0 if not applicable</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setbank(System.IntPtr,BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.BankType,System.Int32)">
            <summary>
            set current bank for type of memory
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="type">type of memory</param>
            <param name="bank">bank to set</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setaddrbank(System.IntPtr,System.UInt16,System.Int32)">
            <summary>
            set current bank for type of memory at address
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="addr">address for memory type</param>
            <param name="bank">bank to set</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getsrambank(System.IntPtr)">
            <summary>
            get current sram bank
            </summary>
            <param name="core">opaque state pointer</param>
            <returns>current sram bank</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_getregs(System.IntPtr,System.Int32[])">
            <summary>
            get reg and flag values
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="dest">length of at least 10, please</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_setregs(System.IntPtr,System.Int32[])">
            <summary>
            set reg and flag values
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="src">length of at least 10, please</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.Gameboy.LibGambatte.gambatte_settime(System.IntPtr,System.UInt64)">
            <summary>
            set time in dividers (2^21/sec)
            </summary>
            <param name="core">opaque state pointer</param>
            <param name="dividers">time in dividers</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.GBA.IGBAGPUViewable.SetScanlineCallback(System.Action,System.Int32)">
            <summary>
            calls correspond to entering hblank (maybe) and in a regular frame, the sequence of calls will be 160, 161, ..., 227, 0, ..., 159
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.GBA.LibmGBA.BizStartGetState(System.IntPtr,System.IntPtr@,System.Int32@)">
            <summary>
            start a savestate operation
            </summary>
            <param name="p">private parameter to be passed to BizFinishGetState</param>
            <param name="size">size of buffer to be allocated for BizFinishGetState</param>
            <returns>if false, operation failed and BizFinishGetState should not be called</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.GBA.LibmGBA.BizFinishGetState(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            finish a savestate operation.  if StartGetState returned true, this must be called else memory leaks
            </summary>
            <param name="p">returned by BizStartGetState</param>
            <param name="dest">buffer of length size</param>
            <param name="size">returned by BizStartGetState</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.GBHawk.GBHawk.SynthesizeFrontendBGPal">
            <summary>
            Produces a palette in the form that certain frontend inspection tools.
            May or may not return a reference to the core's own palette, so please don't mutate.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.GBHawk.GBHawk.SynthesizeFrontendSPPal">
            <summary>
            Produces a palette in the form that certain frontend inspection tools.
            May or may not return a reference to the core's own palette, so please don't mutate.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.GBHawk.IPort">
            <summary>
            Represents a GB add on
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64.#ctor(BizHawk.Emulation.Common.GameInfo,System.Byte[],System.Byte[],BizHawk.Emulation.Cores.Nintendo.N64.N64Settings,BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings)">
            <summary>
            Create mupen64plus Emulator
            </summary>
            <param name="game">Game information of game to load</param>
            <param name="file">Rom that should be loaded</param>
            <param name="rom">rom data with consistent endianness/order</param>
            <param name="syncSettings">N64SyncSettings object</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.api">
            <summary>
            mupen64 DLL Api
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.audioBuffer">
            <summary>
            Buffer for audio data
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.SamplingRate">
            <summary>
            Currently active sampling rate
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.Resampler">
            <summary>
            Resampler for audio output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.#ctor(BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi)">
            <summary>
            Creates a N64 Audio subsystem
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Audio.DoAudioFrame">
            <summary>
            Fetches the audio buffer from mupen64plus and pushes it into the
            Resampler for audio output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Input.GetControllerInput(System.Int32)">
            <summary>
            Translates controller input from EmuHawk into
            N64 controller data
            </summary>
            <param name="i">Id of controller to update and shove</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Input.ReadController(System.Int32)">
            <summary>
            Read all buttons from a controller and translate them
            into a form the N64 understands
            </summary>
            <param name="num">Number of controller to translate</param>
            <returns>Bit list of pressed buttons</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Input.SetControllerPakType(System.Int32,BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings.N64ControllerSettings.N64ControllerPakType)">
            <summary>
            Sets the controller pak of the controller to the specified type
            </summary>
            <param name="controller">Id of the controller</param>
            <param name="type">Type to which the controller pak is set. Currently only NO_PAK and MEMORY_CARD are supported</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64Input.SetControllerConnected(System.Int32,System.Boolean)">
            <summary>
            Sets the connection status of the controller
            </summary>
            <param name="controller">Id of the controller to connect or disconnect</param>
            <param name="connectionStatus">New status of the controller connection</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings.N64ControllerSettings.N64ControllerPakType">
            <summary>
            Enumeration defining the different N64 controller pak types
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings.N64ControllerSettings.PakType">
            <summary>
            Type of the pak inserted in the controller
            Currently only NO_PAK and MEMORY_CARD are
            supported. Other values may be set and
            are recognized but they have no function
            yet. e.g. TRANSFER_PAK makes the N64
            recognize a transfer pak inserted in
            the controller but there is no
            communication to the transfer pak.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings.N64ControllerSettings.IsConnected">
            <summary>
            Connection status of the controller i.e.:
            Is the controller plugged into the N64?
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64SyncSettings.N64ControllerSettings.Clone">
            <summary>
            Clones this object
            </summary>
            <returns>New object with the same values</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64VideoProvider.#ctor(BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi,BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.VideoPluginSettings)">
            <summary>
            Creates N64 Video system with mupen64plus backend
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64VideoProvider.DoVideoFrame">
            <summary>
            Fetches current frame buffer from mupen64
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.N64VideoProvider.SetBufferSize(System.Int32,System.Int32)">
            <summary>
            Sets a new width and height for frame buffer
            </summary>
            <param name="width">New width in pixels</param>
            <param name="height">New height in pixels</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.AudDll">
            <summary>
            Handle to native audio plugin
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.GetBufferSize">
            <summary>
            Gets the size of the mupen64plus audio buffer
            </summary>
            <returns>The size of the mupen64plus audio buffer</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.ReadAudioBuffer">
            <summary>
            Gets the audio buffer from mupen64plus, and then clears it
            </summary>
            <param name="dest">The buffer to fill with samples</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.GetAudioRate">
            <summary>
            Gets the current audio rate from mupen64plus
            </summary>
            <returns>The current audio rate</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.#ctor(BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi)">
            <summary>
            Loads native functions and attaches itself to the core
            </summary>
            <param name="core">Core with loaded core api</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.GetSamplingRate">
            <summary>
            Returns currently used sampling rate
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.GetAudioBufferSize">
            <summary>
            Returns size of bytes currently in the audio buffer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusAudioApi.GetAudioBuffer(System.Int16[])">
            <summary>
            Returns bytes currently in the audiobuffer
            Afterwards audio buffer is cleared
            buffer.Length must be greater than GetAudioBufferSize()
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.CoreStartup">
            <summary>
            Initializes the the core DLL
            </summary>
            <param name="APIVersion">Specifies what API version our app is using. Just set this to 0x20001</param>
            <param name="ConfigPath">Directory to have the DLL look for config data. "" seems to disable this</param>
            <param name="DataPath">Directory to have the DLL look for user data. "" seems to disable this</param>
            <param name="Context">Use "Core"</param>
            <param name="DebugCallback">A function to use when the core wants to output debug messages</param>
            <param name="context2">Use ""</param>
            <param name="dummy">Use IntPtr.Zero</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.CoreShutdown">
            <summary>
            Cleans up the core
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.CoreAttachPlugin">
            <summary>
            Connects a plugin DLL to the core DLL
            </summary>
            <param name="PluginType">The type of plugin that is being connected</param>
            <param name="PluginLibHandle">The DLL handle for the plugin</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.CoreDetachPlugin">
            <summary>
            Disconnects a plugin DLL from the core DLL
            </summary>
            <param name="PluginType">The type of plugin to be disconnected</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.ConfigOpenSection">
            <summary>
            Opens a section in the global config system
            </summary>
            <param name="SectionName">The name of the section to open</param>
            <param name="ConfigSectionHandle">A pointer to the pointer to use as the section handle</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.ConfigSetParameter">
            <summary>
            Sets a parameter in the global config system
            </summary>
            <param name="ConfigSectionHandle">The handle of the section to access</param>
            <param name="ParamName">The name of the parameter to set</param>
            <param name="ParamType">The type of the parameter</param>
            <param name="ParamValue">A pointer to the value to use for the parameter (must be an int right now)</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.ConfigSetParameterStr">
            <summary>
            Sets a parameter in the global config system
            </summary>
            <param name="ConfigSectionHandle">The handle of the section to access</param>
            <param name="ParamName">The name of the parameter to set</param>
            <param name="ParamType">The type of the parameter</param>
            <param name="ParamValue">A pointer to the value to use for the parameter (must be a string)</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.savestates_save_bkm">
            <summary>
            Saves the mupen64plus state to the provided buffer
            </summary>
            <param name="buffer">A byte array to use to save the state. Must be at least 16788288 + 1024 bytes</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.savestates_load_bkm">
            <summary>
            Loads the mupen64plus state from the provided buffer
            </summary>
            <param name="buffer">A byte array filled with the state to load. Must be at least 16788288 + 1024 bytes</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugMemGetPointer">
            <summary>
            Gets a pointer to a section of the mupen64plus core
            </summary>
            <param name="mem_ptr_type">The section to get a pointer for</param>
            <returns>A pointer to the section requested</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.MemGetSize">
            <summary>
            Gets the size of the given memory area
            </summary>
            <param name="mem_ptr_type">The section to get the size of</param>
            <returns>The size of the section requested</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.init_saveram">
            <summary>
            Initializes the saveram (eeprom and 4 mempacks)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.save_saveram">
            <summary>
            Pulls out the saveram for bizhawk to save
            </summary>
            <param name="dest">A byte array to save the saveram into</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.load_saveram">
            <summary>
            Restores the saveram from bizhawk
            </summary>
            <param name="src">A byte array containing the saveram to restore</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.biz_read_memory">
            <summary>
            Reads from the "system bus"
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.biz_write_memory">
            <summary>
            Writes to the "system bus"
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.PluginStartup">
            <summary>
            Initializes the plugin
            </summary>
            <param name="CoreHandle">The DLL handle for the core DLL</param>
            <param name="Context">Giving a context to the DebugCallback</param>
            <param name="DebugCallback">A function to use when the plugin wants to output debug messages</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.PluginShutdown">
            <summary>
            Cleans up the plugin
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugCallback">
            <summary>
            Handles a debug message from mupen64plus
            </summary>
            <param name="Message">The message to display</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.FrameCallback">
            <summary>
            This will be called every time a new frame is finished
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.VICallback">
            <summary>
            This will be called every time a VI occurs
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.RenderCallback">
            <summary>
            This will be called every time before the screen is drawn
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.StartupCallback">
            <summary>
            This will be called after the emulator is setup and is ready to be used
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.TraceCallback">
            <summary>
            Type of the trace callback
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.SetTraceCallback">
            <summary>
            Sets the trace callback
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.GetRegisters">
            <summary>
            Gets the CPU registers
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugInitCallback">
            <summary>
            This will be called when the debugger is initialized
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugUpdateCallback">
            <summary>
            This will be called when the debugger hits a breakpoint or executes one instruction in stepping mode
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugVICallback">
            <summary>
            This will be called during each vertical interrupt
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugSetCallbacks">
            <summary>
             Sets the debug callbacks
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugBreakpointLookup">
            <summary>
            This function searches through all current breakpoints in the debugger to find one that matches the given input parameters.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugBreakpointCommand">
            <summary>
            This function is used to process common breakpoint commands, such as adding, removing, or searching the breakpoints
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugGetState">
            <summary>
            Gets a debugger state variable
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugSetRunState">
            <summary>
            Sets the runstate of the emulator
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.DebugStep">
            <summary>
            Continues execution
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.AsyncExecuteEmulator">
            <summary>
            Starts executing the emulator asynchronously
            Waits until the emulator booted up and than returns
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.ExecuteEmulatorThread">
            <summary>
            Starts execution of mupen64plus
            Does not return until the emulator stops
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.connectFunctionPointers">
            <summary>
            Look up function pointers in the dlls
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusApi.set_video_parameters(BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.VideoPluginSettings)">
            <summary>
            Puts plugin settings of EmuHawk into mupen64plus
            </summary>
            <param name="video_settings">Settings to put into mupen64plus</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusInputApi.SetInputCallback">
            <summary>
            Sets a callback to use when the mupen core wants controller buttons
            </summary>
            <param name="inputCallback">The delegate to use</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusInputApi.InputCallback">
            <summary>
            Callback to use when mupen64plus wants input
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusInputApi.RumbleCallback">
            <summary>
            This will be called every time the N64 changes
            rumble
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusInputApi.SetControllerPakType">
            <summary>
            Sets the controller pak type
            </summary>
            <param name="controller">Controller id</param>
            <param name="type">Type id according to (well documented... hurr hurr) mupen api</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusInputApi.SetControllerConnected">
            <summary>
            Connects and disconnects controllers
            </summary>
            <param name="controller">Controller id</param>
            <param name="connected">1 if controller should be connected, 0 if controller should be disconnected</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusVideoApi.ReadScreen2">
            <summary>
            Fills a provided buffer with the mupen64plus framebuffer
            </summary>
            <param name="framebuffer">The buffer to fill</param>
            <param name="width">A pointer to a variable to fill with the width of the framebuffer</param>
            <param name="height">A pointer to a variable to fill with the height of the framebuffer</param>
            <param name="buffer">Which buffer to read: 0 = front, 1 = back</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusVideoApi.ReadScreen2Res">
            <summary>
            Gets the width and height of the mupen64plus framebuffer
            </summary>
            <param name="dummy">Use IntPtr.Zero</param>
            <param name="width">A pointer to a variable to fill with the width of the framebuffer</param>
            <param name="height">A pointer to a variable to fill with the height of the framebuffer</param>
            <param name="buffer">Which buffer to read: 0 = front, 1 = back</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.N64.NativeApi.mupen64plusVideoApi.Getm64pFrameBuffer(System.Int32[],System.Int32@,System.Int32@)">
            <summary>
            This function copies the frame buffer from mupen64plus
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.APU.ExternalQueue(System.Int32)">
            <summary>only call in board.ClockCPU()</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.DatachBarcode.GetOutput">
            <summary>
            d3
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.ExROM.GetExRAMArray">
            <summary>
            use with caution
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.JALECO_SS8806.squeeze(System.Int32)">
            <summary>
            emulate underflow for the appropriate number of bits
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.Namco163Audio.WriteAddr(System.Byte)">
            <summary>
            F800:FFFF
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.Namco163Audio.WriteData(System.Byte)">
            <summary>
            4800:4FFF
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.Namco163Audio.ReadData">
            <summary>
            4800:4FFF
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.Namco163Audio.ch">
            <summary>
            last channel clocked
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.Namco163Audio.Clock">
            <summary>
            119318hz (CPU / 15)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.EMirrorType">
            <summary>
            These are used by SetMirroring() to provide the base class nametable mirroring service.
            Apparently, these are not used for internal build configuration logic
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NesBoardBase.PeekCart(System.Int32)">
            <summary>
            derived classes should override this if they have peek-unsafe logic
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.BankSwitched">
            <summary>
            Whether the NSF is bankswitched
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.InitBankSwitches">
            <summary>
            the bankswitch values to be used before the INIT routine is called
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.FakePRG">
            <summary>
            An image of the entire PRG space where the unmapped files are located
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.prg_banks_4k">
            <summary>
            PRG bankswitching
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.Patch_Vectors">
            <summary>
            whether vectors are currently patched. they should not be patched when running init/play routines because data from the ends of banks might get used
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.CurrentSong">
            <summary>
            Current 1-indexed song number (1 is the first song)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.InitPending">
            <summary>
            Whether the INIT routine needs to be called
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFBoard.ButtonState">
            <summary>
            Previous button state for button press handling
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM">
            <summary>
            describes a 24C01 or 24C02 as connected to a BANDAI-FCG
            </summary>
            <remarks>
            <see href="http://pdf1.alldatasheet.com/datasheet-pdf/view/56094/ATMEL/24C01.html">24C01</see><br/>
            <see href="http://www.atmel.com/Images/doc0180.pdf">24C02 and others</see>
            </remarks>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.Big">
            <summary>
            true if 256byte
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.OutEnable">
            <summary>aux circuitry? D7 of data byte</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.SCK">
            <summary>asserted by master</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.SDA">
            <summary>asserted by master</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.PullDown">
            <summary>true if the SEEPROM is trying to pull down the SDA line</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.BitsLeft">
            <summary>number of bits left to send\recv of current byte</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.Data">
            <summary>current data byte in progress</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.Addr">
            <summary>current chip addr</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.ClockByteWrite">
            <summary>
            called on the 9th bit of a write
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.ClockBit(System.Boolean)">
            <summary>
            called on rising edge of SCK.  output bit, if any, can be set by PullDown
            </summary>
            <param name="bit">input bit</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.ReadBit(System.Boolean)">
            <summary>
            read a bit back from eprom, might be mapped in 6000:7fff
            </summary>
            <param name="deadbit">bit from NES.DB</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.SEEPROM.#ctor(System.Boolean)">
            <param name="Big">256 byte instead of 128 byte</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.SxROM.ppuclock">
            <summary>number of cycles since last WritePRG()</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.BootGodDb.acquire">
            <summary>
            blocks until the DB is done loading
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.CartInfo">
            <summary>
            All information necessary for a board to set itself up
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.CartInfo.InesMirroring">
            <summary>
            in [0,3]; combination of bits 0 and 3 of flags6.
            try not to use; will be null for BootGod-identified roms always
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.biosrom">
            <summary>FDS bios image; should be 8192 bytes</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.diskimage">
            <summary>.FDS disk image</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.currentside">
            <summary>currently loaded side of the .FDS image, 0 based</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.diskdiffs">
            <summary>collection of diffs (as provided by the RamAdapter) for each side in the .FDS image</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.diskenable">
            <summary>disk io ports enabled; see 4023.0</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.soundenable">
            <summary>sound io ports enabled; see 4023.1</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.reg4026">
            <summary>read on 4033, write on 4026</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.timerlatch">
            <summary>timer reload</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.timervalue">
            <summary>timer current value</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDS.timerreg">
            <summary>4022.0,1</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.FDS.SetDiskImage(System.Byte[])">
            <summary>
            should only be called once, before emulation begins
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.FDS.GetDiskImage">
            <summary>
            returns the currently set disk image.  no effect on emulation (provided the image is not modified).
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.waverampos">
            <summary>
            playback position, clocked by main unit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.volumespd">
            <summary>
            volume level or envelope speed, depending on r4080_7
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4080_6">
            <summary>
            increase volume with envelope
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4080_7">
            <summary>
            disable volume envelope
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.frequency">
            <summary>
            speed to clock main unit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4083_6">
            <summary>
            disable volume and sweep
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4083_7">
            <summary>
            silence channel
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.sweepspd">
            <summary>
            sweep gain or sweep speed, depending on r4084_7
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4084_6">
            <summary>
            increase sweep with envelope
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4084_7">
            <summary>
            disable sweep unit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.sweepbias">
            <summary>
            7 bit signed
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.modfreq">
            <summary>
            speed to clock modulation unit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.r4087_7">
            <summary>
            disable modulation unit
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.modtable">
            <summary>
            ring buffer, only 32 entries on hardware
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.modtablepos">
            <summary>
            playback position
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.waveram_writeenable">
            <summary>
            channel silenced and waveram writable
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.FDSAudio.Clock">
            <summary>
             ~1.7mhz
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.FDSChunk.Hidden">
            <summary>
            true if BIOS will ignore this file.  this flag is not directly stored.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter">
            <summary>
            implements the FDS disk drive hardware, more or less
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.CCITT(System.UInt16,System.Int32)">
            <summary>
            advance a 16 bit CRC register with 1 new input bit.  x.25 standard
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.CCITT_8(System.UInt16,System.Byte)">
            <summary>
            advance a 16 bit CRC register with 8 new input bits.  x.25 standard
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.originaldisk">
            <summary>the original contents of this disk when it was loaded.  for virtual saveram diff</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.disk">
            <summary>currently loaded disk side (ca 65k bytes)</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.diskpos">
            <summary>current disk location in BITS, not bytes</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.disksize">
            <summary>size of current disk in BITS, not bytes</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.writeprotect">
            <summary>true if current disk is writeprotected</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.cycleswaiting">
            <summary>ppu cycles until next action</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.state">
            <summary>physical state of the drive</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.cached4025">
            <summary>cached 4025 write; can be modified internally by some things</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.irq">
            <summary>can be raised on byte transfer complete</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.transferreset">
            <summary>true if 4025.1 is set to true</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.crc">
            <summary>
            16 bit CRC register.  in normal operation, will become all 0 on finishing a read (see x.25 spec for more details)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.writecomputecrc">
            <summary>true if data being written to disk is currently being computed in CRC</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Eject">
            <summary>
            eject the loaded disk
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Insert(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            insert a new disk.  might have to eject first???
            </summary>
            <param name="side">least significant bits appear first on physical disk</param>
            <param name="bitlength">length of disk in bits</param>
            <param name="writeprotect">disk is write protected</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.InsertBrokenImage(System.Byte[],System.Boolean)">
            <summary>
            insert a side image from an fds disk
            </summary>
            <param name="side">65500 bytes from a broken-ass .fds file to be corrected</param>
            <param name="writeprotect">disk is write protected</param>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.NumBytes">
            <summary>
            memorydomain debugging
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.PeekData(System.Int64)">
            <summary>
            memorydomain debugging
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.RamAdapterState.RUNNING">
            <summary>moving over the disk</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.RamAdapterState.INSERTING">
            <summary>new disk/side into the drive</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.RamAdapterState.SPINUP">
            <summary>motor starting</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.RamAdapterState.RESET">
            <summary>head moving back to beginning</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.RamAdapterState.IDLE">
            <summary>nothing happening</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.SetCycles">
            <summary>
            set cycleswaiting param after a state change
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Write4024(System.Byte)">
            <summary>
            data write reg
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Write4025(System.Byte)">
            <summary>
            control reg
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Read4030">
            <summary>
            general status reg, some bits are from outside the RamAdapter class
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Read4031">
            <summary>
            more status stuff
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Read4032">
            <summary>
            more status stuff
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.RamAdapter.Clock">
            <summary>
            clock at ~5.37mhz
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable">
            <summary>
            supports the PPU and NT viewers.  do not modify any returned arrays!
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetPalette">
            <summary>
            get the 512 color overall palette in use
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.BGBaseHigh">
            <summary>
            true if bg tile indexes start at 0x1000 instead of 0x0000
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.SPBaseHigh">
            <summary>
            true if sp tile indexes start at 0x1000 instead of 0x0000 (8x8 mode only)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.SPTall">
            <summary>
            true if sprites are 8x16
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetPPUBus">
            <summary>
            get the first 0x3000 bytes of ppu data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetPalRam">
            <summary>
            get the 32 byte palette ram
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetOam">
            <summary>
            returns the object attribute memory
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.PeekPPU(System.Int32)">
            <summary>
            return one byte of PPU bus data
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetExTiles">
            <summary>
            get MMC5 extile source data
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.ExActive">
            <summary>
            true if MMC5 and ExAttr mode is active
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetExRam">
            <summary>
            get MMC5 exram for exattr mode
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.GetCHRROM">
            <summary>
            get memory domain for chr rom; return null if RAM or other N/A.  for direct viewing of ROM tiles.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.InstallCallback1(System.Action,System.Int32)">
            <summary>
            install a callback to run at a particular scanline
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.InstallCallback2(System.Action,System.Int32)">
            <summary>
            install a callback to run at a particular scanline
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.RemoveCallback1">
            <summary>
            remove previously installed callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.INESPPUViewable.RemoveCallback2">
            <summary>
            remove previously installed callback
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.FindBoard(BizHawk.Emulation.Cores.Nintendo.NES.CartInfo,BizHawk.Emulation.Cores.Nintendo.NES.EDetectionOrigin,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            finds a board class which can handle the provided cart
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.IdentifyFromBootGodDB(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            looks up from the bootgod DB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.IdentifyFromGameDB(System.String)">
            <summary>
            looks up from the game DB
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.NES.cpuclockrate">
            <summary>
            Clock speed of the main cpu in hz.  Used to time audio synthesis, which runs off the cpu clock.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.SetPalette(System.Byte[0:,0:])">
            <summary>
            Sets the provided palette as current.
            Applies the current deemph settings if needed to expand a 64-entry palette to 512
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.LookupColor(System.Int32)">
            <summary>
            looks up an internal NES pixel value to an rgb int (applying the core's current palette and assuming no deemph)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.FetchMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for FetchMemory which inserts CDL logic
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.NES.ReadMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for ReadMemory which inserts CDL logic
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.LightgunDelegate">
            <summary>
            callback type for PPU to tell if there's light for a lightgun to detect
            </summary>
            <param name="x">x coordinate on screen</param>
            <param name="y">y coordinate on screen</param>
            <returns>true if there is light</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo">
            <summary>
            stores information about the strobe lines controlled by $4016
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT0">
            <summary>
            the current value of $4016.0; strobes regular controller ports
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT1">
            <summary>
            the current value of $4016.1; strobes expansion port
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT2">
            <summary>
            the current value of $4016.2; strobes expansion port
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT0old">
            <summary>
            the previous value or $4016.0 (for edge sensitive equipment)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT1old">
            <summary>
            the previous value or $4016.1 (for edge sensitive equipment)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.OUT2old">
            <summary>
            the previous value or $4016.2 (for edge sensitive equipment)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo.#ctor(System.Byte,System.Byte)">
            <param name="oldValue">the old latched $4016 byte</param>
            <param name="newValue">the new latched $4016 byte</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.IControllerDeck">
            <summary>
            the main system deck, handling all $4016 writes and $4016/$4017 reads
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.IControllerDeck.ControllerDef">
            <remarks>
            implementations create a single <see cref="T:BizHawk.Emulation.Common.ControllerDefinition"/> in their ctors and will always return a reference to it;
            caller may mutate it
            </remarks>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.IControllerDeck.Strobe(BizHawk.Emulation.Cores.Nintendo.NES.StrobeInfo,BizHawk.Emulation.Common.IController)">
            <summary>
            call whenever $4016 is written
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.IControllerDeck.ReadA(BizHawk.Emulation.Common.IController)">
            <summary>
            call whenever $4016 is read
            </summary>
            <returns>bits 0-4 are valid</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.IControllerDeck.ReadB(BizHawk.Emulation.Common.IController)">
            <summary>
            call whenever $4017 is read
            </summary>
            <returns>bits 0-4 are valid</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.IFamicomExpansion">
            <summary>
            a peripheral that plugs into the famicom expansion port
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.IFamicomExpansion.ReadA(BizHawk.Emulation.Common.IController)">
            <summary>
            read data from $4016
            </summary>
            <returns>only bit 1 is valid</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.IFamicomExpansion.ReadB(BizHawk.Emulation.Common.IController)">
            <summary>
            read data from $4017
            </summary>
            <returns>bits 1-4 are valid</returns>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.INesPort">
            <summary>
            a peripheral that plugs into either of the two NES controller ports
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.NesDeck">
            <summary>
            a NES or AV famicom, with two attached devices
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.ControllerNES">
            <summary>
            a NES controller; also used internally to represent the two famicom controllers
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.ControllerSNES">
            <summary>
            a SNES controller plugged into a NES? heresy
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.ArkanoidNES">
            <summary>
            vaus paddle, the NES (not famicom) version
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.Zapper.PPUCallback">
            <summary>
            returns true if light was detected at the ppu coordinates specified
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.NES.VSZapper.PPUCallback">
            <summary>
            returns true if light was detected at the ppu coordinates specified
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.ArkanoidFam">
            <summary>
            vaus controller that plugs into a famicom's expansion port
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.NES.NSFFormat.StartingSong">
            <summary>
            1-indexed. 0 is an invalid value, I guess
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.NES.Palettes.Load_FCEUX_Palette(System.Byte[])">
            <summary>
            Loads a simple 192 byte (64 entry RGB888) or 1536 byte (64*8 = 512 entry) palette. FCEUX uses these, as do almost every NES emulator.
            </summary>
            <param name="fileContents">192 or 1536 bytes, the contents of the palette file</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.NES.Unif">
            <summary>
            at least it's not iNES 2.0...
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.Sameboy.Sameboy">
            <summary>
            a gameboy/gameboy color emulator wrapped around native C libsameboy
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.LibsnesApi.CopyAscii(System.Int32,System.String)">
            <summary>
            Copy an ascii string into libretro. It keeps the copy.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.LibsnesApi.CopyBytes(System.Int32,System.Byte[])">
            <summary>
            Copy a buffer into libretro. It keeps the copy.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.LibsnesApi.SetBytes(System.Int32,System.Byte[],System.Action)">
            <summary>
            Locks a buffer and sets it into libretro. You must pass a delegate to be executed while that buffer is locked.
            This is meant to be used for avoiding a memcpy for large roms (which the core is then just going to memcpy again on its own)
            The memcpy has to happen at some point (libretro semantics specify [not literally, the docs don't say] that the core should finish using the buffer before its init returns)
            but this limits it to once.
            Moreover, this keeps the c++ side from having to free strings when they're no longer used (and memory management is trickier there, so we try to avoid it)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.LibsnesApi.SetAscii(System.Int32,System.String,System.Action)">
            <summary>
            see SetBytes
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESControllerDefExtensions.AddLightGun(BizHawk.Emulation.Common.ControllerDefinition,System.String)">
            <remarks>
            problem: when you're in 240 line mode, the limit on Y needs to be 0-239. when you're in 224 mode, it needs to be 0-224.
            perhaps the deck needs to account for this...
            for reference Snes9x is always in 224 mode
            </remarks>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.ILibsnesController.PortType">
            <summary>
            the type to pass back to the native init
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.ILibsnesController.GetState(BizHawk.Emulation.Common.IController,System.Int32,System.Int32)">
            <summary>
            respond to a native core poll
            </summary>
            <param name="controller">controller input from user, remapped</param>
            <param name="index">libsnes specific value, sometimes multitap number</param>
            <param name="id">libsnes specific value, sometimes button number</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.LibsnesCore.snes_input_state(System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="port">0 or 1, corresponding to L and R physical ports on the snes</param>
            <param name="device">LibsnesApi.SNES_DEVICE enum index specifying type of device</param>
            <param name="index">meaningless for most controllers.  for multitap, 0-3 for which multitap controller</param>
            <param name="id">button ID enum; in the case of a regular controller, this corresponds to shift register position</param>
            <returns>for regular controllers, one bit D0 of button status.  for other controls, varying ranges depending on id</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGModeIsMode7Type(BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGMode)">
            <summary>
            is a BGMode a mode7 type (mode7, mode7ext, mode7DC)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo">
            <summary>
            this class is not 'smart' - it wont recompute values for you. it's meant to be read only (we should find some way to protect write access to make that clear)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.BGMode">
            <summary>
            what type of BG is it?
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.BGModeIsMode7Type">
            <summary>
            is this BGMode a mode7 type (mode7, mode7ext, mode7DC)
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.Enabled">
            <summary>
            Is the layer even enabled?
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.SCADDR">
            <summary>
            screen and tiledata register values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.TDADDR">
            <summary>
            screen and tiledata register values
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.SCSIZE">
            <summary>
            SCSIZE register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.Mode">
            <summary>
            which Mode this BG came from
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.ScreenAddr">
            <summary>
            the address of the screen data
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.TiledataAddr">
            <summary>
            the address of the tile data
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.ScreenSize">
            <summary>
            Screen size (shape, really.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.Bpp">
            <summary>
            the BPP of the BG, as derived from the current mode
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.TILESIZE">
            <summary>
            value of the tilesize register; 1 implies 16x16 tiles
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.MainEnabled">
            <summary>
            enabled on MAIN Screen via $212C
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.SubEnabled">
            <summary>
            enabled on SUB Screen via $212D
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.MathEnabled">
            <summary>
            enabled for color math via $2131
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.HOFS">
            <summary>
            scroll registers
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.VOFS">
            <summary>
            scroll registers
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.TileSize">
            <summary>
            TileSize; 8 or 16
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.ScreenSizeInTiles">
            <summary>
            The size of the layer, in tiles
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.ScreenSizeInPixels">
            <summary>
            The size of the layer, in pixels. This has factored in the selection of 8x8 or 16x16 tiles
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.BGInfo.PaletteSelection">
            <summary>
            returns information about what colors could possibly be used for this bg
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.OAMInfo.Address">
            <summary>
            tiledata address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.DecodeMode7BG(System.Int32*,System.Int32,System.Boolean)">
            <summary>
            decodes a mode7 BG. youll still need to paletteize and colorize it.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.DecodeBG(System.Int32*,System.Int32,BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.TileEntry[],System.Int32,BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.ScreenSize,System.Int32,System.Int32,System.Int32)">
            <summary>
            decodes a BG. youll still need to paletteize and colorize it.
            someone else has to take care of calculating the starting color from the mode and layer number.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.FetchTilemap(System.Int32,BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.ScreenSize)">
            <summary>
            fetches a tilemap. this is simple; apparently only the screen size (shape) is a factor (not the tile size)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.CacheTiles">
            <summary>
            Caches all tiles at the 2bpp, 4bpp, and 8bpp decoded states.
            we COULD defer this til we need it, you know. sort of a cool idea, not too hard
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.CacheTiles_Merge(System.Int32)">
            <summary>
            merges one type of tiles with another to create the higher-order bitdepth.
            TODO - templateize this when we change it to c++
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.Decode8x8x2bpp(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            decodes an 8x8 tile to a linear framebuffer type thing. fundamental unit of tile decoding.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.RenderMode7TilesToScreen(System.Int32*,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>
            renders the mode7 tiles to a screen with the predefined size.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.RenderTilesToScreen(System.Int32*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            renders the tiles to a screen of the crudely specified size.
            we might need 16x16 unscrambling and some other perks here eventually.
            provide a start color to use as the basis for the palette
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Nintendo.SNES.SNESGraphicsDecoder.GetPalette">
            <summary>
            returns the current palette, transformed into an int array, for more convenience
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.PCEngine.PCEngine.InitCDLMappings">
            <summary>
            informs the CPU of the general memory layout, so it can do CDL
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.PCEngine.QuickQueue`1.Enqueue(`0)">
            <exception cref="T:System.Exception">called while at capacity</exception>
        </member>
        <member name="M:BizHawk.Emulation.Cores.PCEngine.QuickQueue`1.Dequeue">
            <exception cref="T:System.Exception">called while empty</exception>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M68000.MC68000.M">
            <summary>Machine/Interrupt mode</summary>
            <remarks>TODO probably have some switch logic maybe</remarks>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M68000.MC68000.S">
            <summary>Supervisor/User mode</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M68000.MC68000.X">
            <summary>Extend Flag</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M68000.MC68000.N">
            <summary>Negative Flag</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M68000.MC68000.Z">
            <summary>Zero Flag</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M68000.MC68000.V">
            <summary>Overflow Flag</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M68000.MC68000.C">
            <summary>Carry Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M68000.MC68000.SR">
            <summary>Status Register</summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1">
             <summary>
             Fairchild F3850 (F8) CPU
             Author: Asnivor
             
             The F8 microprocessor is made up of separate interchangeable devices
             The Channel F has:
            		* x1 F3850 CPU (central processing unit)
            		* x2 F3851 PSU (program storage unit)
             The CPU does not have its own data counters or program counters, rather each F8 component connected to the CPU
             holds their own PCs and SPs and are all connected to the ROMC (ROM control) pins that are serviced by the CPU.
             Every device must respond to changes in the CPU ROMC pins output and they each update their PCs and DCs in the same way.
             e.g. SPs and PCs should always be identical
             Each device has a factory ROM mask applied and with every ROMC change observed is able to know whether it should respond (via the shared data bus)
             or not based on the value within its counters.
             
             For this reason we will hold the PCs and SPs within the F3850 implementation.
             
             We are currently also *not* using a separate F3851 implementation. In reality the F3851 chip has/does:
            		* 1024 byte masked ROM
            		* x2 16-bit program counters
            		* x1 16-bit data counter
            		* Programmable timer
            		* Interrupt logic
            
             Note: Programmable timer and interrupt logic from the F3851 is not currently emulated
             </summary>
             <remarks>
             this type parameter might look useless—and it is—but after monomorphisation,
             this way happens to perform better than the alternative
             </remarks>
             <seealso cref="T:BizHawk.Emulation.Cores.Components.FairchildF8.IF3850Link"/>
            <summary>
            Disassembler
            </summary>
            <summary>
            ALU Operations
            </summary>
            <summary>
            Internal Registers
            </summary>
            <summary>
            Vectors of Instruction Operations
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ExecuteOne">
            <summary>
            Runs a single CPU clock cycle
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PopulateCURINSTR(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Optimization method to set cur_instr
            </summary>	
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_IO_Func(System.Byte,System.Byte)">
            <summary>
            Helper method moving from IO pins to accumulator
            (complement and flags set)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OUT_Func(System.Byte,System.Byte)">
            <summary>
            Helper method moving from accumulator to IO pins 
            (complement)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_Func(System.Byte,System.Byte)">
            <summary>
            Helper function for transferring data between registers
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.SR_Func(System.Byte,System.Byte)">
            <summary>
            Right shift 'src' 'shift' positions (zero fill)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.SL_Func(System.Byte,System.Byte)">
            <summary>
            Left shift 'src' 'shift' positions (zero fill)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ADD_Func(System.Byte,System.Byte,System.Byte)">
            <summary>
            Binary addition
            Statuses modified: OVF, ZERO, CARRY, SIGN 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ADDD_Func(System.Byte,System.Byte)">
            <summary>
            Decimal Add
            http://www.bitsavers.org/components/fairchild/f8/67095664_F8_Guide_To_Programming_1976.pdf - page 40
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.CI_Func">
            <summary>
            Binary add the two's compliment of the accumulator to the value on the databus
            Set flags accordingly but accumlator is not touched
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AND_Func(System.Byte,System.Byte)">
            <summary>
            Logical AND regs[dest] with regs[src] and store the result in regs[dest]
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OR_Func(System.Byte,System.Byte)">
            <summary>
            Logical OR regs[dest] with regs[src] and store the result in regs[dest]
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XOR_Func(System.Byte,System.Byte)">
            <summary>
            The destination (regs[dest]) is XORed with (regs[src]).
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.Regs">
            <summary>
            Registers (counters and scratchpad)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.A">
            <summary>
            Accumulator
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.W">
            <summary>
            Status Register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ISAR">
            <summary>
            Indirect Scratchpad Address Register
            (6bit)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PC0h">
            <summary>
            Primary Program Counter (high byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PC0l">
            <summary>
            Primary Program Counter (low byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PC1h">
            <summary>
            Backup Program Counter (high byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PC1l">
            <summary>
            Backup Program Counter (low byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DC0h">
            <summary>
            Data counter (high byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DC0l">
            <summary>
            Data Counter (low byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ALU0">
            <summary>
            Temporary Arithmetic Storage
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ALU1">
            <summary>
            Temporary Arithmetic Storage
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DB">
            <summary>
            Data Bus
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IO">
            <summary>
            IO Bus/Latch
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ZERO">
            <summary>
            0x00 value for arithmetic ops
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ONE">
            <summary>
            0x01 value for arithmetic ops
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.BYTE">
            <summary>
            0xFF value for arithmetic ops
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DC1h">
            <summary>
            Backup Data counter (high byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DC1l">
            <summary>
            Backup Data Counter (low byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IRQVh">
            <summary>
            IRQ Vector (high byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IRQVl">
            <summary>
            IRQ Vector (low byte)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IRQR">
            <summary>
            IRQ Request Pending
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.FlagS">
            <summary>
            Status Register - Sign Flag
            When the results of an ALU operation are being interpreted as a signed binary number, the high oidei bit (bit 7) represents the sign of the number
            At the conclusion of instructions that may modify the Accumulator bit 7, the S bit (W register bit 0) is set to the complement of the Accumulator bit 7.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.FlagC">
            <summary>
            Status Register - Carry Flag
            The C bit (W register bit 1) may be visualized as an extension of an 8-bit data unit; i.e., bit 8 of a 9-bit data unit. 
            When two bytes are added and the sum is greater than 255, the carry out of bit 7 appears in the C bit.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.FlagZ">
            <summary>
            Status Register - Zero Flag
            The Z bit (W Register bit 2) is set whenever an arithmetic or logical operation generates a zero result. 
            The Z bit is reset to 0 when an arithmetic or logical operation could have generated a zero result, but did not.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.FlagO">
            <summary>
            Status Register - Overflow Flag
            The high order Accumulator bit (bit 7) represents the sign of the number. 
            When the Accumulator contents are being interpreted as a signed binary number, some method must be provided for indicating carries out of the highest numeric bit (bit 6 of the Accumulator). 
            This is done using the 0 bit (W register bit 3). After arithmetic operations, the 0 bit is set to the EXCLUSIVE-OR of Carry Out of bits 6 and bits 7. This simplifies signed binary arithmetic. 
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.FlagICB">
            <summary>
            Status Register - Interrupt Master Enable Flag
            External logic can alter the operations sequence within the CPU by interrupting ongoing operations. 
            However, interrupts are allowed only when t (W register bit 4) is set to 1; interrupts are disallowed when the ICB bit is reset to O.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IRQRequest">
            <summary>
            Signals that IRQ Request is pending
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.RegPC0">
            <summary>
            Access to the full 16-bit Primary Program Counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.RegPC1">
            <summary>
            Access to the full 16-bit Backup Program Counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.RegDC0">
            <summary>
            Access to the full 16-bit Data Counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.RegDC1">
            <summary>
            Access to the full 16-bit Backup Data Counter
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.RegIRQV">
            <summary>
            Access to the full 16-bit IRQ Vector
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_KU">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_KL">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_QU">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_QL">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_KU_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_KL_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_QU_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_QL_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_K_P">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_P_K">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_IS">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_IS_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PK">
            <summary>
            PK - CALL TO SUBROUTINE DIRECT AND RETURN FROM SUBROUTINE DIRECT
            The contents of the Program Counter Registers (PCO) are stored in the Stack Registers (PC1), 
            then the contents of the Scratchpad K Registers (Registers 12 and 13 of scratchpad memory) are transferred into the Program Counter Registers.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_P0_Q">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_Q_DC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_DC_Q">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_DC_H">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_H_DC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.SR(System.Byte)">
            <summary>
            SR - SHIFT RIGHT
            The contents of the accumulator are shifted right either one or four bit positions, depending on the value of the SR instruction operand.
            Statuses modified: ZERO, SIGN 
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.SL(System.Byte)">
            <summary>
            SL - SHIFT LEFT
            The contents of the accumulator are shifted left either one or four bit positions, depending upon the value of the SL instruction operand. 
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LM">
            <summary>
            LM - LOAD ACCUMULATOR FROM MEMORY
            The contents of the memory byte addressed by the DCO registers are loaded into the accumulator. 
            The contents of the DCO registers are incremented as a resu It of the LM instruction execution.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ST">
            <summary>
            ST - STORE TO MEMORY
            The contents of the accumulator are stored in the memory location addressed by the Data Counter (DCO) registers.
            The DC registers' contents are incremented as a result of the instruction execution.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.COM">
            <summary>
            COM - COMPLEMENT
            The accumulator is loaded with its one's complement.
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Status unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LNK">
            <summary>
            LNK - LlNK CARRY TO THE ACCUMULATOR
            The carry bit is binary added to the least significant bit of the accumulator. The result is stored in the accumulator.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DI">
            <summary>
            DI - DISABLE INTERRUPT
            The interrupt control bit, ICB, is reset; no interrupt requests will be acknowledged by the 3850 CPU
            Statuses reset: ICB 
            Statuses unaffected: OVF, ZERO, CARRY, SIGN
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.EI">
            <summary>
            EI - ENABLE INTERRUPT
            The interrupt control bit is set. Interrupt requests will now be acknowledged by the CPU.
            ICB is set to 1. All other status bits are unaffected. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.POP">
            <summary>
            POP - RETURN FROM SUBROUTINE
            The contents of the Stack Registers (PC1) are transferred to the Program Counter Registers (PCO).
            No status bits are modified.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_W_J">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_J_W">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.INC">
            <summary>
            INC - INCREMENT ACCUMULATOR 
            The content of the accumulator is increased by one binary count.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LI">
            <summary>
            LI - LOAD IMMEDIATE 
            The value provided by the operand of the LI instruction is !oaded into the accumuator. 
            No status bits are affected. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NI">
            <summary>
            NI - AND IMMEDIATE
            An 8-bit value provided by the operand of the NI instruction is ANDed with the contents of the accumulator. 
            The results are stored in the accumulator. 
            Statuses reset to 0: OVF, CARRY
            Statuses modified: ZERO, SIGN 
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OI">
            <summary>
            OI - OR IMMEDIATE
            An 8-bit value provided by the operand of the 1/0 instruction is ORed with the contents of the accumulator. 
            The results are stored in the accumulator. 
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XI">
            <summary>
            XI - EXCLUSIVE-OR IMMEDIATE
            The contents of the 8-bit value provided by the operand of the XI instruction are EXCLUSIVE-ORed with the contents of the accumulator. 
            The results are stored in the accumulator. 
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AI">
            <summary>
            AI - ADD IMMEDIATE TO ACCUMULATOR
            The 8-bit (two hexadecimal digit) value provided by the instruction operand is added to the current contents of the accumulator. 
            Binary addition is performed.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.CI">
            <summary>
            Compare Immediate
            The contents of the accumulator are subtracted from the operand of the CI instruction. 
            The result is not saved but the status bits are set or reset to reflect the results of the operation
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ILLEGAL">
            <summary>
            Illegal Opcode - just do a short cycle NOP
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.IN">
            <summary>
            IN - INPUT LONG ADDRESS
            The data input to the 1/0 port specified by the operand of the IN instruction is stored in the accumulator.
            Statuses modified: ZERO, SIGN 
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OUT">
            <summary>
            OUT - OUTPUT LONG ADDRESS 
            The I/O port addressed by the operand of the OUT instruction is loaded with the contents of the accumulator. 
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.PI">
            <summary>
            PI - CALL TO SUBROUTINE IMMEDIATE
            The contents of the Program Counters are stored in the Stack Registers, PC1, then the 16-bit address contained in the operand of the 
            PI instruction is loaded into the Program Counters.· The accumulator is used as a temporary storage register during transfer of the most significant byte of the address. 
            Previous accumulator results will be altered.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.JMP">
            <summary>
            JMP - Branch Immediate
            As the result of a JMP instruction execution, a branch to the memory location addressed by the second and third bytes of the instruction occurs. 
            The second byte contains the high order eight bits of the memory address; 
            the third byte contains the low order eight bits of the memory address.
            No status bits are affected. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DCI">
            <summary>
            DCI - LOAD DC IMMEDIATE
            The DCI instruction is a three-byte instruction. The contents of the second byte replace the high order byte of the DC0 registers; 
            the contents of the third byte replace the low order byte of the DCO registers.
            The status bits are not affected. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NOP">
            <summary>
            NOP - NO OPERATION
            No function is performed. 
            No status bits are modified.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XDC">
            <summary>
            XDC - EXCHANGE DATA COUNTERS
            Execution of the instruction XDC causes the contents of the auxiliary data counter registers (DC1) to be exchanged with the contents of the data counter registers (DCO). 
            This instruction is only significant when a 3852 or 3853 Memory Interface device is part of the system configuration.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DS(System.Byte)">
            <summary>
            OS - DECREMENT SCRATCHPAD CONTENT
            The content of the scratchpad register addressed by the operand (Sreg) is decremented by one binary count. 
            The decrement is performed by adding H'FF' to the scratchpad register.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DS_ISAR">
            <summary>
            Same as DS, but the register pointed to by ISAR is affected
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DS_ISAR_INC">
            <summary>
            Same as DS, but the register pointed to by ISAR is affected, then the ISAR itself is incremented
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DS_ISAR_DEC">
            <summary>
            Same as DS, but the register pointed to by ISAR is affected, then the ISAR itself is decremented
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_ISAR">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_ISAR_INC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            ISAR incremented
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_A_ISAR_DEC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            ISAR deccremented
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_R_A(System.Byte)">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_ISAR_A">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_ISAR_A_INC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            ISAR incremented
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LR_ISAR_A_DEC">
            <summary>
            LR - LOAD REGISTER 
            The LR group of instructions move one or two bytes of data between a source and destination register.
            ISAR decremented
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LISU(System.Byte)">
            <summary>
            LISU - LOAD UPPER OCTAL DIGIT OF ISAR
            A 3-bit value provided by the LlSU instruction operand is loaded into the three most significant bits of the ISAR. The three least significant bits of the ISAR are not altered. 
            No status bits are affected. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LISL(System.Byte)">
            <summary>
            LlSL - LOAD LOWER OCTAL DIGIT OF ISAR
            A 3-bit value provided by the USL instruction operand is loaded into the three least significant bits of the ISAR. The three most significant bits of the ISAR are not altered.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.LIS(System.Byte)">
            <summary>
            LIS - LOAD IMMEDIATE SHORT 
            A 4-bit value provided by the LIS instruction operand is loaded into the four least significant bits of the accumulator. 
            The most significant four bits of the accumulator are set to "0".
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.BT(System.Byte)">
            <summary>
            Branch on TRUE
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.BF(System.Byte)">
            <summary>
            Branch on FALSE
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AM">
            <summary>
            AM - ADD (BINARY) MEMORY TO ACCUMULATOR 
            The content of the memory iocation addressed by the DC0 registers is added to the accumulator. The sum is returned in the accumulator. 
            Memory is not altered. Binary addition is performed. The contents of the DCO registers are incremented by 1
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AMD">
            <summary>
            AMD - DECIMAL ADD. MEMORY TO ACCUMULATOR
            The accumulator and the memory location addressed by the DCO registers are assumed to contain two BCD digits. 
            The content of the address memory byte is added to the contents of the accumulator to give a BCD result in the accumulator
            Statuses modified: CARRY, ZERO
            Statuses not significant: OVF, SIGN 
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NM">
            <summary>
            NM - LOGICAL AND FROM MEMORY
            The content of memory addressed by the data counter registers is ANDed with the content of the accumulator. 
            The results are stored in the accumulator. The contents of the data counter registers are incremented. 
            Statuses reset to 0: OVF, CARRY 
            Statuses modified: ZERO, SIGN 
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OM">
            <summary>
            OM - LOGICAL IIOR" FROM MEMORY
            The content of memory byte addressed by the data counter registers is ORed with the content of the accumulator. 
            The results are stored in the accumulator. The data counter registers are incremented. 
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XM">
            <summary>
            XM - EXCLUSIVE-OR FROM MEMORY
            The content of the memory location addressed by the DCO registers is EXCLUSIVE-ORed with the contents of the accumulator. 
            The results are stored in the accumulator. The DCO registers are incremented.
            Statuses modified: ZERO, SIGN 
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.CM">
            <summary>
            CM - COMPARE MEMORY TO ACCUMULATOR 
            The CM instruction is the same as the CI instruction except the memory contents addressed by the DCO registers, 
            instead of an immediate value, are compared to the contents of the accumu lator.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ADC">
            <summary>
            ADC - ADD ACCUMULATOR TO DATA COUNTER
            The contents of the accumulator are treated as a signed binary number, and are added to the contents of every DCO register. 
            The result is stored in the DCO registers. The accumulator contents do not change.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.BR7">
            <summary>
            Branch if any of the 3 low bits of ISAR are reset
            Testing of ISAR is immediate so we will have to lose a CPU tick in the next phase
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.INS_0(System.Byte)">
            <summary>
            INS - INPUT SHORT ADDRESS
            Data input to the I/O port specified by the operand of the INS instruction is loaded into the accumulator. 
            An I/O port with an address within the range 0 through 1 may be accessed by this instruction
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.INS_1(System.Byte)">
            <summary>
            INS - INPUT SHORT ADDRESS
            Data input to the I/O port specified by the operand of the INS instruction is loaded into the accumulator. 
            An I/O port with an address within the range 4 through 15 may be accessed by this instruction
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OUTS_0(System.Byte)">
            <summary>
            OUTS - OUTPUT SHORT ADDRESS
            The I/O port addressed by the operand of the OUTS instruction object code is loaded with the contents of the accumulator. 
            I/O ports with addresses from 0 to 1 may be accessed by this instruction. (Outs O or 1 is CPU port only.)
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.OUTS_1(System.Byte)">
            <summary>
            OUTS - OUTPUT SHORT ADDRESS
            The I/O port addressed by the operand of the OUTS instruction object code is loaded with the contents of the accumulator. 
            I/O ports with addresses from 3 to 15 may be accessed by this instruction.
            No status bits are modified. 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AS(System.Byte)">
            <summary>
            AS - BINARY ADDITION, SCRATCHPAD MEMORY TO ACCUMULATOR
            The content of the scratchpad register referenced by the instruction operand (Sreg) is added to the accumulator using binary addition. 
            The result of the binary addition is stored in the accumulator. 
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AS_IS">
            <summary>
            AS - BINARY ADDITION, SCRATCHPAD MEMORY TO ACCUMULATOR
            The content of the scratchpad register referenced indirectly by ISAR is added to the accumulator using binary addition. 
            The result of the binary addition is stored in the accumulator. 
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AS_IS_INC">
            <summary>
            AS - BINARY ADDITION, SCRATCHPAD MEMORY TO ACCUMULATOR
            The content of the scratchpad register referenced indirectly by ISAR is added to the accumulator using binary addition. 
            The result of the binary addition is stored in the accumulator. 
            The low order three bits of ISAR are incremented after the scratchpad register is accessed.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.AS_IS_DEC">
            <summary>
            AS - BINARY ADDITION, SCRATCHPAD MEMORY TO ACCUMULATOR
            The content of the scratchpad register referenced indirectly by ISAR is added to the accumulator using binary addition. 
            The result of the binary addition is stored in the accumulator. 
            The low order three bits of ISAR are decremented after the scratchpad register is accessed.
            Statuses modified: OVF, ZERO, CARRY, SIGN
            Statuses unaffected: ICB 
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ASD(System.Byte)">
            <summary>
            ASD - DECIMAL ADD, SCRATCHPAD TO ACCUMULATOR
            The ASD instruction is similar to the AMD instruction, except that instead of adding the contents of the memory byte addressed by the DCO registers, 
            the content of the scratchpad byte addressed by operand (Sreg) is added to the accumulator. 
            Statuses modified: CARRY, ZERO
            Statuses not significant: OVF, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ASD_IS">
            <summary>
            ASD - DECIMAL ADD, SCRATCHPAD TO ACCUMULATOR
            The ASD instruction is similar to the AMD instruction, except that instead of adding the contents of the memory byte addressed by the DCO registers, 
            the content of the scratchpad byte referenced indirectly by ISAR is added to the accumulator. 
            Statuses modified: CARRY, ZERO
            Statuses not significant: OVF, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ASD_IS_INC">
            <summary>
            ASD - DECIMAL ADD, SCRATCHPAD TO ACCUMULATOR
            The ASD instruction is similar to the AMD instruction, except that instead of adding the contents of the memory byte addressed by the DCO registers, 
            the content of the scratchpad byte referenced indirectly by ISAR is added to the accumulator. 
            The low order three bits of ISAR are incremented after the scratchpad register is accessed.
            Statuses modified: CARRY, ZERO
            Statuses not significant: OVF, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.ASD_IS_DEC">
            <summary>
            ASD - DECIMAL ADD, SCRATCHPAD TO ACCUMULATOR
            The ASD instruction is similar to the AMD instruction, except that instead of adding the contents of the memory byte addressed by the DCO registers, 
            the content of the scratchpad byte referenced indirectly by ISAR is added to the accumulator. 
            The low order three bits of ISAR are decremented after the scratchpad register is accessed.
            Statuses modified: CARRY, ZERO
            Statuses not significant: OVF, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XS(System.Byte)">
            <summary>
            XS - EXCLUSIVE-OR FROM SCRATCHPAD
            The content of the scratchpad register referenced by the operand (Sreg) is EXCLUSIVE-ORed with the contents of the accumulator.
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XS_IS">
            <summary>
            XS - EXCLUSIVE-OR FROM SCRATCHPAD
            The content of the register referenced by ISAR is EXCLUSIVE-ORed with the contents of the accumulator.
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XS_IS_INC">
            <summary>
            XS - EXCLUSIVE-OR FROM SCRATCHPAD
            The content of the register referenced by ISAR is EXCLUSIVE-ORed with the contents of the accumulator.
            ISAR is incremented
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.XS_IS_DEC">
            <summary>
            XS - EXCLUSIVE-OR FROM SCRATCHPAD
            The content of the register referenced by ISAR is EXCLUSIVE-ORed with the contents of the accumulator.
            ISAR is deccremented
            Statuses modified: ZERO, SIGN
            Statuses reset: OVF, CARRY 
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NS(System.Byte)">
            <summary>
            NS - LOGICAL AND FROM SCRATCHPAD MEMORY
            The content of the scratch pad register addressed by the operand (Sreg) is ANDed with the content of the accumulator. 
            The results are stored in the accumulator. 
            Statuses reset to 0: OVF, CARRY
            Statuses modified: ZERO, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NS_IS">
            <summary>
            NS - LOGICAL AND FROM SCRATCHPAD MEMORY
            The content of the scratch pad register addressed by the Register ISAR is pointing at is ANDed with the content of the accumulator. 
            The results are stored in the accumulator. 
            Statuses reset to 0: OVF, CARRY
            Statuses modified: ZERO, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NS_IS_INC">
            <summary>
            NS - LOGICAL AND FROM SCRATCHPAD MEMORY
            The content of the scratch pad register addressed by the Register ISAR is pointing at is ANDed with the content of the accumulator. 
            The results are stored in the accumulator. 
            ISAR is incremented
            Statuses reset to 0: OVF, CARRY
            Statuses modified: ZERO, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.NS_IS_DEC">
            <summary>
            NS - LOGICAL AND FROM SCRATCHPAD MEMORY
            The content of the scratch pad register addressed by the Register ISAR is pointing at is ANDed with the content of the accumulator. 
            The results are stored in the accumulator. 
            ISAR is decremented
            Statuses reset to 0: OVF, CARRY
            Statuses modified: ZERO, SIGN
            Statuses unaffected: ICB
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DO_BRANCH(System.Int32)">
            <summary>
            Branching Operation
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.FairchildF8.F3850`1.DONT_BRANCH(System.Int32)">
            <summary>
            No-Branching Operation
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagC">
            <summary>Carry Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagZ">
            <summary>Zero Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagI">
            <summary>Interrupt Disable Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagD">
            <summary>Decimal Mode Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagB">
            <summary>Break Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagT">
            <summary>T... Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagV">
            <summary>Overflow Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.H6280.HuC6280.FlagN">
            <summary>Negative Flag</summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.I8048.I8048.PopulateCURINSTR(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set cur_instr
            </summary>	
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.MC6800.MC6800.PopulateCURINSTR(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set cur_instr
            </summary>	
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.MC6809.MC6809.PopulateCURINSTR(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set cur_instr
            </summary>	
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1">
            <remarks>
            this type parameter might look useless—and it is—but after monomorphisation,
            this way happens to perform better than the alternative
            </remarks>
            <seealso cref="T:BizHawk.Emulation.Cores.Components.M6502.IMOS6502XLink"/>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagC">
            <summary>Carry Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagZ">
            <summary>Zero Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagI">
            <summary>Interrupt Disable Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagD">
            <summary>Decimal Mode Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagB">
            <summary>Break Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagT">
            <summary>T... Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagV">
            <summary>Overflow Flag</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.FlagN">
            <summary>Negative Flag</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.AneConstant">
            <summary>
            For the unsupported opcode, ANE.
            If your core requires a specific constant for this opcode, set it here.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.M6502.MOS6502X`1.LxaConstant">
            <summary>
            For the unsupported opcode, LXA.
            If your core requires a specific constant for this opcode, set it here.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.M6502.MOS6502X.Disassemble(System.UInt16,System.Int32@,System.Func{System.UInt16,System.Byte})">
            <summary>
            disassemble not from our own memory map, but from the supplied memory domain
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.W65816.W65816">
            <remarks>
            Ported from C-lang project https://github.com/pelrun/Dispel at <c>cb38eeee0</c> (specifically, the file <c>65816.c</c>).<br/>
            The DisPel software is unlicensed, and is thus assumed to be copyrighted without any transfer of rights.
            This reproduction is made with the assumption that it cannot be infringing because every part of its structure is necessary for its function (in the US, scènes à faire).
            </remarks>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.Z80A.Z80A`1">
            <remarks>
            this type parameter might look useless—and it is—but after monomorphisation,
            this way happens to perform better than the alternative
            </remarks>
            <seealso cref="T:BizHawk.Emulation.Cores.Components.Z80A.IZ80ALink"/>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.Z80A.Z80A`1.PopulateBUSRQ(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set BUSRQ
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.Z80A.Z80A`1.PopulateMEMRQ(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set MEMRQ
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.Z80A.Z80A`1.PopulateCURINSTR(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Optimization method to set cur_instr
            </summary>	
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.MMC5Audio.WriteExp(System.Int32,System.Byte)">
            <param name="addr">0x5000..0x5015</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.MMC5Audio.ReadROMTrigger(System.Byte)">
            <summary>
            call for 8000:bfff reads
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.IMixedSoundProvider">
            <summary>
            An interface that extends a sound provider to provide mixing capabilities through the SoundMixer class
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.Sunsoft5BAudio">
            <summary>
            YM2149F variant
            this implementation is quite incomplete
            http://wiki.nesdev.com/w/index.php/Sunsoft_5B_audio
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.SyncSoundMixer">
             <summary>
             ISoundProvider mixer that generates a single ISoundProvider output from multiple ISoundProvider sources
             Currently only supports sync (not async)
            
             Bizhawk expects ISoundProviders to output at 44100KHz, so this is what SyncSoundMixer does. Therefore, try to make
             sure that your child ISoundProviders also do this I guess.
             
             This is currently used in the ZX Spectrum and CPC cores but others may find it useful in future
             </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer._soundProviders">
            <summary>
            Currently attached ChildProviders
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.SyncSoundMixer.FinalMaxVolume">
            <summary>
            The final output max volume
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Components.SyncSoundMixer.MixBalanceMethod">
            <summary>
            How the sound sources are balanced against each other
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer._targetSampleCount">
            <summary>
            If specified the output buffer of the SyncSoundMixer will always contain this many samples
            You should probably nearly always specify a value for this and get your ISoundProvider sources
            to get as close to this nsamp value as possible. Otherwise the number of samples will
            be based on the highest nsamp out of all the child providers for that specific frame
            Useful examples:
            	882 - 44100KHz - 50Hz
            	735 - 44100Khz - 60Hz
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.#ctor(BizHawk.Emulation.Cores.Components.SoundMixBalance,System.Int16,System.Nullable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="mixBalanceMethod">Whether each providers MaxVolume is reduced to an equal share of the final max volume value</param>
            <param name="maxVolume">The final 'master' max volume</param>
            <param name="targetSampleCount">
            If specified the output buffer of the SyncSoundMixer will always contain this many samples
            If left null the output buffer will contain the highest number of samples out of each of the providers every frame
            </param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.PinSource(BizHawk.Emulation.Common.ISoundProvider,System.String)">
            <summary>
            Adds an ISoundProvider to the SyncSoundMixer
            </summary>
            <param name="source">The source ISoundProvider</param>
            <param name="sourceDescription">An ident string for the ISoundProvider (useful when debugging)</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.PinSource(BizHawk.Emulation.Common.ISoundProvider,System.String,System.Int16)">
            <summary>
            Adds an ISoundProvider to the SyncSoundMixer
            </summary>
            <param name="source">The source ISoundProvider</param>
            <param name="sourceDescription">An ident string for the ISoundProvider (useful when debugging)</param>
            <param name="sourceMaxVolume">The MaxVolume level for this particular ISoundProvider</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.UnPinSource(BizHawk.Emulation.Common.ISoundProvider)">
            <summary>
            Removes an existing ISoundProvider from the SyncSoundMixer
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.EqualizeVolumes">
            <summary>
            Sets each pinned sound provider's MaxVolume based on the MixBalanceMethod
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.GetHigestSampleCount">
            <summary>
            Returns the value of the highest nsamp in the SoundProviders collection
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider">
            <summary>
            Instantiated for every ISoundProvider source that is added to the mixer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.SoundProvider">
            <summary>
            The Child ISoundProvider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.ProviderDescription">
            <summary>
            Identification string
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.MaxVolume">
            <summary>
            The max volume for this provider
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.InputBuffer">
            <summary>
            Stores the incoming samples
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.InputNSamp">
            <summary>
            The incoming number of samples
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.OutputBuffer">
            <summary>
            Stores the processed samples ready for mixing
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.OutputNSamp">
            <summary>
            The output number of samples
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.GetSamples">
            <summary>
            Fetches sample data from the child ISoundProvider
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.SyncSoundMixer.ChildProvider.PrepareOutput(System.Int32)">
            <summary>
            Ensures the output buffer is ready for mixing based on the supplied nsamp value
            Overflow samples will be omitted and underflow samples will be empty air
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Components.SoundMixBalance">
            <summary>
            Defines how mixed sound sources should be balanced
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SoundMixBalance.Equalize">
            <summary>
            Each sound source's max volume will be set to MaxVolume / nSources
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.SoundMixBalance.MasterHardLimit">
            <summary>
            Each sound source's individual max volume will be respected but the final MaxVolume will be limited to MaxVolume
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Components.VRC6Alt.#ctor(System.Action{System.Int32})">
            <param name="enqueuer">a place to dump deltas to</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.A">
            <summary>rate of increment for accumulator</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.F">
            <summary>frequency.  actually a reload value</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.E">
            <summary>enable</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.RSHIFT">
            <summary>reload shift, from $9003</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.count">
            <summary>frequency counter</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.accum">
            <summary>accumulator</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.acount">
            <summary>saw reset counter</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Saw.output">
            <summary>latched output, 0..31</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.V">
            <summary>volume, 0..15</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.D">
            <summary>duty comparison.  forced to max when x000.7 == 1</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.F">
            <summary>frequency.  actually a reload value</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.E">
            <summary>enable</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.RSHIFT">
            <summary>reload shift, from $9003</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.count">
            <summary>frequency counter</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.duty">
            <summary>duty counter</summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Components.VRC6Alt.Pulse.output">
            <summary>latched output, 0..15</summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sega.GGHawkLink.IPort">
            <summary>
            Represents a GG add on
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sega.MasterSystem.SMS.ReadMemoryMapper">
            <summary>
            The ReadMemory callback for the mapper
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sega.MasterSystem.SMS.WriteMemoryMapper">
            <summary>
            The WriteMemory callback for the wrapper
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sega.MasterSystem.SMS.FetchMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for FetchMemory which inserts CDL logic
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sega.MasterSystem.SMS.ReadMemory_CDL(System.UInt16)">
            <summary>
            A wrapper for ReadMemory which inserts CDL logic
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sega.MasterSystem.IPort">
            <summary>
            Represents a SMS controller
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sony.PSX.Octoshock.DiscInterface">
            <summary>
            Wraps the ShockDiscRef returned from the DLL and acts as a bridge between it and a DiscSystem disc
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sony.PSX.Octoshock.CalculateResolution(BizHawk.Emulation.Cores.Sony.PSX.OctoshockDll.eVidStandard,BizHawk.Emulation.Cores.Sony.PSX.Octoshock.Settings,System.Int32,System.Int32)">
            <summary>
            Calculates what the output resolution would be for the given input resolution and settings
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sony.PSX.OctoshockDll.eShockRenderType">
            <summary>
            this is implemented as an overall render type instead of a horizontal clip control
            in case the Framebuffer render type ever develops any differences in its Y-handling.
            At that time, we might need to change the GUI to separate the vertical and horizontal components, or something like that
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigUser">
            <summary>
            Represents a user's view of what equipment is plugged into the PSX FIO
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigLogical">
            <summary>
            Represents a baked-down view of what's plugged into the PSX FIO.
            But really, users are interested in it too (its what produces the player number assignments)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigLogical.NumPlayers">
            <summary>
            Total number of players defined
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigLogical.PlayerAssignments">
            <summary>
            The player number on each of the input slots
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigLogical.DevicesPlayer">
            <summary>
            The device type associated with each player
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Sony.PSX.OctoshockFIOConfigLogical.NumMemcards">
            <summary>
            Total number of connected memcards
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_new">
            <summary>
            create new instance
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_delete(System.IntPtr)">
            <summary>
            delete instance, freeing all associated memory
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_reset(System.IntPtr)">
            <summary>
            hard reset
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_advance(System.IntPtr,BizHawk.Emulation.Cores.WonderSwan.BizSwan.Buttons,System.Boolean,System.Int32[],System.Int16[],System.Int32@,System.Boolean@)">
            <summary>
            frame advance
            </summary>
            <param name="buttons">input to use on this frame</param>
            <param name="novideo">true to skip all video rendering</param>
            <param name="surface">uint32 video output buffer</param>
            <param name="soundbuff">int16 sound output buffer</param>
            <param name="soundbuffsize">[In] max hold size of soundbuff [Out] number of samples actually deposited</param>
            <param name="IsRotated">(out) true if the screen is rotated left 90</param>
            <returns>true if lagged</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_load(System.IntPtr,System.Byte[],System.Int32,BizHawk.Emulation.Cores.WonderSwan.BizSwan.SyncSettings@,System.Boolean@)">
            <summary>
            load rom
            </summary>
            <param name="IsRotated">(out) true if screen is rotated left 90</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_saveramsize(System.IntPtr)">
            <summary>
            get size of saveram
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_saveramload(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            load saveram into core
            </summary>
            <param name="size">should be same as bizswan_saveramsize()</param>
            <returns>false if size mismatch</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_saveramsave(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            save saveram from core
            </summary>
            <param name="maxsize">should be same as bizswan_saveramsize()</param>
            <returns>false if size mismatch</returns>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_putsettings(System.IntPtr,BizHawk.Emulation.Cores.WonderSwan.BizSwan.Settings@)">
            <summary>
            put non-sync settings, can be done at any time
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_getmemoryarea(System.IntPtr,System.Int32,System.IntPtr@,System.Int32@,System.IntPtr@)">
            <summary>
            get a memory area
            </summary>
            <param name="index">start at 0, increment until return is false</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.WonderSwan.BizSwan.bizswan_getnecreg(System.IntPtr,BizHawk.Emulation.Cores.WonderSwan.BizSwan.NecRegs)">
            <summary>
            return a CPU register
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.WonderSwan.BizSwan.Settings.BWPalette">
            <summary>
            map bw shades to output colors, [0] = darkest, [15] = lightest
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.WonderSwan.BizSwan.Settings.ColorPalette">
            <summary>
            map color shades to output colors, bits 0-3 blue, bits 4-7 green, bits 8-11 red
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.CoreInventory">
            <summary>
            finds and instantiates IEmulator cores
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreInventory.AllCores">
            <summary>keys are system IDs; values are core/ctor info for all that system's cores</summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreInventory.Core.Name">
            <summary>
            (hopefully) a CoreNames value
            </summary>
            <value></value>
        </member>
        <member name="M:BizHawk.Emulation.Cores.CoreInventory.Core.Create(BizHawk.Emulation.Cores.ICoreInventoryParameters)">
            <summary>
            Instantiate an emulator core
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.CoreInventory.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            create a core inventory, collecting all IEmulators from some assemblies
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.GameDbPreference">
            <summary>
            The gamedb has requested this core for this game
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.UserPreference">
            <summary>
            The user has indicated in preferences that this is their favorite core
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.High">
            <summary>
            A very good core that should be preferred over normal cores.  Don't use this?
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.Normal">
            <summary>
            Most cores should use this
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.Low">
            <summary>
            Experimental, special use, or garbage core
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.CorePriority.SuperLow">
            <summary>
            TODO:  Do we need this?  Does it need a better name?
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.ICoreInventoryParameters">
            <summary>
            What CoreInventory needs to synthesize CoreLoadParameters for a core
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.IRomAsset.Game">
            <summary>
            GameInfo for this individual asset.  Doesn't make sense a lot of the time;
            only use this if your individual rom assets are full proper games when considered alone.
            Not guaranteed to be set in any other situation.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreLoadParameters`2.Settings">
            <summary>
            Settings previously returned from the core.  May be null.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreLoadParameters`2.SyncSettings">
            <summary>
            Sync Settings previously returned from the core.  May be null.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreLoadParameters`2.Roms">
            <summary>
            All roms that should be loaded as part of this core load.
            Order may be significant. Does not include firmware or other general resources.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.CoreLoadParameters`2.Discs">
            <summary>
            All discs that should be loaded as part of this core load.
            Order may be significant.
            </summary>
            <value></value>
        </member>
        <member name="T:BizHawk.Emulation.Cores.CoreNames">
            <summary>
            holds the names of ported and Hawk cores as consts,
            to be used for <see cref="T:BizHawk.Emulation.Common.CoreAttribute">[Core]</see> and various front-end needs
            (though sadly not in Designer files)
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.FileIDType">
            <summary>
            Each of these should ideally represent a single file type.
            However for now they just may resemble a console, and a core would know how to parse some set of those after making its own determination.
            If formats are very similar but with small differences, and that determination can be made, then it will be in the ExtraInfo in the FileIDResult
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileIDResult.Confidence">
            <summary>
            a percentage between 0 and 100 assessing the confidence of this result
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileIDResult.ExtraInfo">
            <summary>
            extra information which could be easily gotten during the file ID (region, suspected homebrew, CRC invalid, etc.)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileIDResults.ShouldTryDisc">
            <summary>
            indicates whether the client should try again after mounting the disc image for further inspection
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.FileID.IdentifyParams">
            <summary>
            parameters for an Identify job
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileID.IdentifyParams.Extension">
            <summary>
            The extension of the original file (with or without the .)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileID.IdentifyParams.SeekableStream">
            <summary>
            a seekable stream which can be used
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileID.IdentifyParams.Disc">
            <summary>
            the file in question mounted as a disc
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.FileID.Identify(BizHawk.Emulation.Cores.FileID.IdentifyParams)">
            <summary>
            performs wise heuristics to identify a file.
            this will attempt to return early if a confident result can be produced.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.FileID.IdentifySimple(BizHawk.Emulation.Cores.FileID.IdentifyParams)">
            <summary>
            performs wise heuristics to identify a file (simple version)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.FileID.ExtensionHandlers">
            <summary>
            testers to try for each extension, along with a default for the extension
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.FileID.CheckMagic(System.IO.Stream,System.Collections.Generic.IEnumerable{BizHawk.Emulation.Cores.FileID.SimpleMagicRecord},System.Int32[])">
            <summary>
            checks for the magic string (bytewise ASCII check) at the given address
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.FileID.Test_Simple(BizHawk.Emulation.Cores.FileID.IdentifyJob,BizHawk.Emulation.Cores.FileIDType,BizHawk.Emulation.Cores.FileID.SimpleMagicRecord[])">
            <summary>
            all magics must pass
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Libretro.LibretroHost.#ctor(BizHawk.Emulation.Common.CoreComm,BizHawk.Emulation.Common.IGameInfo,System.String,System.Boolean)">
            <remarks>does not keep a reference to <paramref name="game"/></remarks>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.LibraryName">
            <summary>
            String containing a friendly display name for the core, but we probably shouldn't use this. I decided it's better to get the user used to using filenames as core 'codenames' instead.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.LibraryVersion">
            <summary>
            String containing a friendly version number for the core library
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.ValidExtensions">
            <summary>
            List of extensions as "sfc|smc|fig" which this core accepts.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.NeedsRomAsPath">
            <summary>
            Whether the core needs roms to be specified as paths (can't take rom data buffersS)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.NeedsArchives">
            <summary>
            Whether the core needs roms stored as archives (e.g. arcade roms). We probably shouldn't employ the dearchiver prompts when opening roms for these cores.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.SupportsNoGame">
            <summary>
            Whether the core can be run without a game provided (e.g. stand-alone games, like 2048)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Libretro.RetroDescription.Variables">
            <summary>
            Variables defined by the core
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Properties.Resources.ReadEmbeddedByteArray(System.String)">
            <param name="embedPath">Dir separator is '<c>.</c>'. Path is relative to <c>&lt;NS></c>.</param>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sound.DualSyncSound">
            <summary>
            this thing more or less ASSumes that the two cores input to it both provide the same number of samples in each go
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Sound.OneBitBeeper">
            <summary>
            A simple 1-bit (mono) beeper/buzzer implementation using blipbuffer
            Simulating the piezzo-electric buzzer found in many old computers (such as the ZX Spectrum or Amstrad CPC)
            Sound is generated by toggling the single input line ON and OFF rapidly
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="blipSampleRate">The sample rate to pass to blipbuffer (this should be 44100 for ISoundProvider)</param>
            <param name="clocksPerFrame">The number of (usually CPU) clocked cycles in one frame</param>
            <param name="framesPerSecond">The number of frames per second (usually either 60 or 50)</param>
            <param name="beeperId">Unique name for this instance (needed for serialization as some cores have more than one active instance of the beeper)</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.Clock(System.Int32)">
            <summary>
            Option to clock the beeper every CPU clock
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.SetClock(System.Int32)">
            <summary>
            Option to directly set the current clock position within the frame
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.ProcessPulseValue(System.Boolean,System.Boolean)">
            <summary>
            Processes an incoming pulse value
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Sound.OneBitBeeper.Volume">
            <summary>
            Beeper volume
            Accepts an int 0-100 value
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Sound.OneBitBeeper.lastVolume">
            <summary>
            The last used volume (used to modify blipbuffer delta values)
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.VolumeConverterIn(System.Int32)">
            <summary>
            Takes an int 0-100 and returns the relevant short volume to output
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Sound.OneBitBeeper.VolumeConverterOut(System.Int32)">
            <summary>
            Takes an short volume and returns the relevant int value 0-100
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.NesSchema.GetPadSchemas(BizHawk.Emulation.Common.IEmulator,System.Action{System.String})">
            <exception cref="T:System.Exception">found <c>ControllerSNES</c></exception>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitData.FileNameBase">
            <summary>
            Filename without extension.  Used in autodetect
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitData.FileNameExt">
            <summary>
            Just the extension.  Used in autodetect.  LOWERCASE PLEASE.
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitData.FileNameFull">
            <summary>
            Full filename.  This will be fopen()ed by the core
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.PreInit">
            <summary>
            Do this before calling anything, even settings queries
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.SetInitialTime(System.Int64)">
            <summary>
            Set the initial frontend time, this needs to be done before InitRom/InitCd
            As init process might query the frontend time
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitRom(BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitData)">
            <summary>
            Load a ROM
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.InitCd(System.Int32)">
            <summary>
            Load some CDs
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.FrameInfo.Command">
            <summary>
            a single command to run at the start of this frame
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.FrameInfo.InputPortData">
            <summary>
            raw data for each input port, assumed to be MAX_PORTS * MAX_PORT_DATA long
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.FrameInfo.FrontendTime">
            <summary>
            If the core calls time functions, this is the value that will be used
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.FrameInfo.DiskIndex">
            <summary>
            disk index to use if close tray is done
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.GetLayerData">
            <summary>
            Gets raw layer data to be handled by NymaCore.GetLayerData
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.SetLayers(System.UInt64)">
            <summary>
            Set enabled layers (or is it disabled layers?).  Only call if NymaCore.GetLayerData() returned non null
            </summary>
            <param name="layers">bitmask in order defined by NymaCore.GetLayerData</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.GetInputDeviceOverride(System.Int32)">
            <summary>
            Gets an input device override for a port
            Corresponds to Game->DesiredInput[port].device_name
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.SetInputDevices(System.String[])">
            <summary>
            Set what input devices we're going to use
            </summary>
            <param name="devices">MUST end with a null string</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.NotifySettingChanged(System.String)">
            <summary>
            Call when a non-sync setting changes value after emulation started.
            The new value should already be available from FrontendSettingQuery
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.SetFrontendFirmwareNotify(BizHawk.Emulation.Cores.Waterbox.LibNymaCore.FrontendFirmwareNotify)">
            <summary>
            Set a callback to be called whenever the core calls MDFN_MakeFName for a firmware, so that we can load firmware on demand
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Waterbox.LibNymaCore.CDTOCCallback">
            <summary>
            Callback to receive a disk TOC
            </summary>
            <param name="dest">Deposit a LibNymaCore.TOC here</param>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.VideoBuffer">
            <summary>
            pointer to the video buffer; set by frontend, filled by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.SoundBuffer">
            <summary>
            pointer to the sound buffer; set by frontend, filled by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.Cycles">
            <summary>
            total number of cycles emulated this frame; set by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.Width">
            <summary>
            width of the output image; set by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.Height">
            <summary>
            height of the output image; set by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.Samples">
            <summary>
            total number of sample pairs produced; set by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.FrameInfo.Lagged">
            <summary>
            true if controllers were not read; set by backend
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.Writable">
            <summary>
            if false, the domain MUST NOT be written to.
            in some cases, a segmentation violation might occur
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.Saverammable">
            <summary>
            if true, this memory domain should be used in saveram.
            can be ignored if the core provides its own saveram implementation
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.OneFilled">
            <summary>
            if true, domain is filled with ones (FF) by default, instead of zeros.
            used in calculating SaveRamModified
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.Primary">
            <summary>
            desginates the default memory domain
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.YugeEndian">
            <summary>
            if true, the most significant bytes are first in multibyte words
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.WordSize1">
            <summary>
            native wordsize.  only a hint
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.WordSize2">
            <summary>
            native wordsize.  only a hint
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.WordSize4">
            <summary>
            native wordsize.  only a hint
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.WordSize8">
            <summary>
            native wordsize.  only a hint
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.Swapped">
            <summary>
            for a yuge endian domain, if true, bytes are stored word-swapped from their native ordering
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryDomainFlags.FunctionHook">
            <summary>
            If true, Data is a function to call and not a pointer
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryArea.Data">
            <summary>
            pointer to the data in memory, or a function hook to call
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryArea.Name">
            <summary>
            null terminated strnig naming the memory domain
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.LibWaterboxCore.MemoryArea.Size">
            <summary>
            size of the domain
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.NymaCore.OverrideButtonName(System.String)">
            <summary>
            Override button names.  Technically this should be per core, but a lot of the names and overrides are the same,
            and an override that doesn't apply to a particular core will just be ignored
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.ControllerAdapter.Devices">
            <summary>
            Device list suitable to pass back to the core
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.NymaCore.ComputeHiddenPorts">
            <summary>
            On some cores, some controller ports are not relevant when certain settings are off (like multitap).
            Override this if your core has such an issue
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.PortResult.Port">
            <summary>
            The port, together with all of its potential contents
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.PortResult.Device">
            <summary>
            What was actually plugged into the port
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.ActualPortData">
            <summary>
            In a fully initialized core, holds information about what was actually plugged in.  Please do not mutate it.
            </summary>
            <value></value>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.NymaCore.GetLayerData">
            <summary>
            Gets a string array of valid layers to pass to SetLayers, or an empty list if that method should not be called
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.NymaCore._syncSettingsActual">
            <summary>
            What this core was actually started with
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettings.Normalize(BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo)">
            <summary>
            remove things that aren't used by the core
            Normally won't do anything, but can be useful in case settings change
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSyncSettings.Normalize(BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo)">
            <summary>
            remove things that aren't used by the core
            Normally won't do anything, but can be useful in case settings change
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo.LayerNames">
            <summary>
            What layers are available to toggle.  If empty, layers cannot be set on this core.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo.Ports">
            <summary>
            What devices can be plugged into each port
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo.HasSettings">
            <summary>
            If true, the settings object has at least one settable value in it
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.NymaSettingsInfo.HasSyncSettings">
            <summary>
            If true, the syncSettings object has at least one settable value in it
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.SettingOverride.Hide">
            <summary>
            If true, hide from user.  Will always be set to its default value in those cases.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.SettingOverride.Default">
            <summary>
            If non-null, replace the original default value with this default value.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.SettingOverride.NonSync">
            <summary>
            If true, put the setting in Settings and not SyncSettings
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.NymaCore.SettingOverride.NoRestart">
            <summary>
            If true, no restart is required to apply the setting.  Only allowed when NonSync == true
            DON'T STEAL THIS FROM MEDNAFLAGS, IT'S NOT SET PROPERLY THERE
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxCore.SaveStateBinaryInternal(System.IO.BinaryWriter)">
            <summary>
            called after the base core saves state.  the core must save any other
            variables that it needs to.
            the default implementation does nothing
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxCore.LoadStateBinaryInternal(System.IO.BinaryReader)">
            <summary>
            called after the base core loads state.  the core must load any other variables
            that were in SaveStateBinaryInternal and reset any native pointers.
            the default implementation does nothing
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.Path">
            <summary>
            path which the main executable and all associated libraries should be found
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.Filename">
            <summary>
            filename of the main executable; expected to be in Path
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.SbrkHeapSizeKB">
            <summary>
            how large the normal heap should be.  it services sbrk calls
            can be 0, but sbrk calls will crash.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.SealedHeapSizeKB">
            <summary>
            how large the sealed heap should be.  it services special allocations that become readonly after init
            Must be > 0 and at least large enough to store argv and envp, and any alloc_sealed() calls
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.InvisibleHeapSizeKB">
            <summary>
            how large the invisible heap should be.  it services special allocations which are not savestated
            Must be > 0 and at least large enough for the internal vtables, and any alloc_invisible() calls
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.PlainHeapSizeKB">
            <summary>
            how large the "plain" heap should be.  it is savestated, and contains
            Must be > 0 and at least large enough for the internal pthread structure, and any alloc_plain() calls
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.MmapHeapSizeKB">
            <summary>
            how large the mmap heap should be.  it is savestated.
            can be 0, but mmap calls will crash.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.SkipCoreConsistencyCheck">
            <summary>
            Skips the check that the wbx file and other associated dlls match from state save to state load.
            DO NOT SET THIS TO TRUE.  A different executable most likely means different meanings for memory locations,
            and nothing will make sense.
            </summary>
        </member>
        <member name="P:BizHawk.Emulation.Cores.Waterbox.WaterboxOptions.SkipMemoryConsistencyCheck">
            <summary>
            Skips the check that the initial memory state (after init, but before any running) matches from state save to state load.
            DO NOT SET THIS TO TRUE.  The initial memory state must be the same for the XORed memory contents in the savestate to make sense.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHost.AddReadonlyFile(System.Byte[],System.String)">
            <summary>
            Adds a file that will appear to the waterbox core's libc.  the file will be read only.
            All savestates must have the same file list, so either leave it up forever or remove it during init!
            </summary>
            <param name="name">the filename that the unmanaged core will access the file by</param>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHost.RemoveReadonlyFile(System.String)">
            <summary>
            Remove a file previously added by AddReadonlyFile.  Frees the internal copy of the filedata, saving memory.
            All savestates must have the same file list, so either leave it up forever or remove it during init!
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHost.AddTransientFile(System.Byte[],System.String)">
            <summary>
            Add a transient file that will appear to the waterbox core's libc.  The file will be readable
            and writable.  Any attempt to save state while the file is loaded will fail.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHost.RemoveTransientFile(System.String)">
            <summary>
            Remove a file previously added by AddTransientFile
            </summary>
            <returns>The state of the file when it was removed</returns>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate.sbrk_size">
            <summary>
            Memory space to serve brk(2)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate.sealed_size">
            <summary>
            Memory space to serve alloc_sealed(3)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate.invis_size">
            <summary>
            Memory space to serve alloc_invisible(3)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate.plain_size">
            <summary>
            Memory space to serve alloc_plain(3)
            </summary>
        </member>
        <member name="F:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate.mmap_size">
            <summary>
            Memory space to serve mmap(2) and friends.
            Calls without MAP_FIXED or MREMAP_FIXED will be placed in this area.
            TODO: Are we allowing fixed calls to happen anywhere in the block?
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReadCallback">
            <summary>
            Read bytes into the buffer.  Return number of bytes read on success, or &lt; 0 on failure.
            permitted to read less than the provided buffer size, but must always read at least 1
            byte if EOF is not reached.  If EOF is reached, should return 0.
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.WriteCallback">
            <summary>
            write bytes.  Return 0 on success, or &lt; 0 on failure.
            Must write all provided bytes in one call or fail, not permitted to write less (unlike reader).
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_create_host(BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.MemoryLayoutTemplate,System.String,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReadCallback,System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Given a guest executable and a memory layout, create a new host environment.  All data will be immediately consumed from the reader,
            which will not be used after this call.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_destroy_host(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Tear down a host environment.  If called while the environment is active, will deactivate it first.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_activate_host(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Activate a host environment.  This swaps it into memory and makes it available for use.
            Pointers to inside the environment are only valid while active.  Uses a mutex internally
            so as to not stomp over other host environments in the same 4GiB slice.
            Ignored if host is already active.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_deactivate_host(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Deactivates a host environment, and releases the mutex.
            Ignored if host is not active
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_proc_addr(System.IntPtr,System.String,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Returns a thunk suitable for calling an exported function from the guest executable.  This pointer is only valid
            while the host is active.  A missing proc is not an error and simply returns 0.  The guest function must be,
            and the returned callback will be, sysv abi, and will only pass up to 6 int/ptr args and no other arg types.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_callin_addr(System.IntPtr,System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Returns a thunk suitable for calling an arbitrary entry point into the guest executable.  This pointer is only valid
            while the host is active.  wbx_get_proc_addr already calls this internally on pointers it returns, so this call is
            only needed if the guest exposes callin pointers that aren't named exports (for instance, if a function returns
            a pointer to another function).
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_proc_addr_raw(System.IntPtr,System.String,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Returns the raw address of a function exported from the guest.  `wbx_get_proc_addr()` is equivalent to
            `wbx_get_callin_addr(wbx_get_proc_addr_raw()).  Most things should not use this directly, as the returned
            pointer will not have proper stack hygiene and will crash on syscalls from the guest.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_callback_addr(System.IntPtr,System.IntPtr,System.Int32,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Returns a function pointer suitable for passing to the guest to allow it to call back while active.
            Slot number is an integer that is used to keep pointers consistent across runs:  If the host is loaded
            at a different address, and some external function `foo` moves from run to run, things will still work out
            in the guest because `foo` was bound to the same slot and a particular slot gives a consistent pointer.
            The returned thunk will be, and the callback must be, sysv abi and will only pass up to 6 int/ptr args and no other arg types.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_seal(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Calls the seal operation, which is a one time action that prepares the host to save states.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_mount_file(System.IntPtr,System.String,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReadCallback,System.IntPtr,System.Boolean,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Mounts a file in the environment.  All data will be immediately consumed from the reader, which will not be used after this call.
            To prevent nondeterminism, adding and removing files is very limited WRT savestates.  Every file added must either exist
            in every savestate, or never appear in any savestates.  All savestateable files must be added in the same order for every run.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_unmount_file(System.IntPtr,System.String,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.WriteCallback,System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Remove a file previously added.  Writer is optional; if provided, the contents of the file at time of removal will be dumped to it.
            It is an error to remove a file which is currently open in the guest.
            If the file has been used in savestates, it does not make sense to remove it here, but nothing will stop you.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_save_state(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.WriteCallback,System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Save state.  Must not be called before seal.  Must not be called with any writable files mounted.
            Must always be called with the same sequence and contents of readonly files.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_load_state(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReadCallback,System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Load state.  Must not be called before seal.  Must not be called with any writable files mounted.
            Must always be called with the same sequence and contents of readonly files that were in the save state.
            Must be called with the same wbx executable and memory layout as in the savestate.
            Errors generally poison the environment; sorry!
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_set_always_evict_blocks(System.Boolean)">
            <summary>
            Control whether the host automatically evicts blocks from memory when they are not active.  For the best performance,
            this should be set to false.  Set to true to help catch dangling pointer issues.  Will be ignored (and forced to true)
            if waterboxhost was built in debug mode.  This is a single global setting.
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_page_len(System.IntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Retrieve the number of pages of guest memory that this host is tracking
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.wbx_get_page_data(System.IntPtr,System.UIntPtr,BizHawk.Emulation.Cores.Waterbox.WaterboxHostNative.ReturnData@)">
            <summary>
            Retrieve basic information for a tracked guest page.  Index should be in 0..wbx_get_page_len().
            1 - readable, implies allocated
            2 - writable
            4 - executable
            0x10 - stack
            0x20 - allocated but not readable (guest-generated "guard")
            0x40 - invisible
            0x80 - dirty
            </summary>
        </member>
        <member name="T:BizHawk.Emulation.Cores.Waterbox.MemoryDomainAccessStub">
            <summary>
            For private use only!  Don't touch
            </summary>
        </member>
        <member name="M:BizHawk.Emulation.Cores.ReflectionCache.EmbeddedResourceStream(System.String)">
            <exception cref="T:System.ArgumentException">not found</exception>
        </member>
    </members>
</doc>
